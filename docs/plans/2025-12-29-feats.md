# Phase 1: Secondary Attack Feat System - Implementation Plan

**Date:** 2025-12-29
**Last Updated:** 2025-12-29
**Status:** PARTIALLY IMPLEMENTED - Needs Major Refactoring
**Scope:** Add 16 class-specific combat feats (4 per class) with resource management, attack variants, passive bonuses, and special abilities

---

## Current Implementation Status (2025-12-29)

### ‚úÖ What's Working
- **Power Attack**: Fully functional in combat (hardcoded, not using feat system)
- **Channel Energy**: Working as AbilityResource for Cleric (2/daily, heals 1d6)
- **Spell Slots**: Tracked but NOT consumed when casting spells
- **Basic Feat Types**: 5 feats defined (Power Attack, Weapon Focus, Toughness, Improved Initiative, Combat Reflexes)
- **Fighter Feat Selection**: Can select 1 feat during character creation

### ‚ö†Ô∏è Partially Implemented
- **Resource System**: Uses `AbilityResource[]` + `SpellSlots` (simpler than planned)
- **Spell Slot Tracking**: Displayed in UI but never decremented
- **Feat Type System**: Basic types exist but lack IDs, prerequisites, resource costs

### ‚ùå Not Implemented
- **11 Advanced Feats**: Vital Strike, Bloody Assault, Precision Strike, etc.
- **Feat Utilities**: No `utils/feats.ts` or `utils/resources.ts`
- **Dynamic Combat Integration**: Power Attack is hardcoded, not using feat system
- **Resource Restoration**: No post-combat resource restoration
- **Spell Slot Consumption**: Spells cast but slots never used
- **Feat UI Components**: No FeatSelector or AbilitySelector components
- **Multi-class Feat Assignment**: Only Fighter gets feats

### üîß Architecture Mismatch
The plan proposed a different resource structure than what's implemented:
- **Planned**: `channel_energy?: {current, max}` + `spell_slots?: {level_0-3}`
- **Actual**: `resources.abilities: AbilityResource[]` + `resources.spellSlots?: SpellSlots`

---

## Overview

This phase extends the feat system from its current minimal state (Power Attack only) to a full tactical combat system with 16 class-specific feats. The implementation needs to:

1. **Step 0: Fix Spell Slot Consumption** - Critical gap: spells don't consume slots
2. **Step 1: Refactor Feat System** - Move from hardcoded Power Attack to dynamic feat utilities
3. **Step 2: Extend Feat Database** - Add 11 missing feats with proper typing
4. **Step 3: Combat Integration** - Apply feats dynamically (passives, attack variants, abilities)
5. **Step 4: UI Implementation** - Add feat selection UI to Combat Screen
6. **Step 5: Character Presets** - Assign feats to all 4 classes

---

## Feat Summary by Class

| Class   | Feat 1 (Offensive)  | Feat 2 (Offensive)   | Feat 3 (Defensive)   | Feat 4 (Utility)      |
|---------|---------------------|----------------------|----------------------|-----------------------|
| Fighter | Power Attack ‚úÖ     | Vital Strike ‚ùå      | Combat Expertise ‚ùå  | Bloody Assault ‚ùå     |
| Rogue   | Weapon Finesse ‚ùå   | Precision Strike ‚ùå  | Combat Expertise ‚ùå  | Critical Focus ‚ùå     |
| Wizard  | Arcane Strike ‚ùå    | Empower Spell ‚ùå     | Combat Expertise ‚ùå  | Disruptive Spell ‚ùå   |
| Cleric  | Power Attack ‚úÖ     | Channel Smite ‚ùå     | Defensive Channel ‚ùå | Guided Hand ‚ùå        |

‚úÖ = Implemented and functional in combat
‚ùå = Not implemented

---

## Step 0: Fix Spell Slot Consumption (CRITICAL)

### Goal

**CRITICAL BUG**: Spell slots are tracked but never consumed when casting spells. This must be fixed before implementing feats that depend on spell slots (Empower Spell, Disruptive Spell).

### Current State
- ‚úÖ Spell slots initialized: `spellSlots: { level0: {max: 99, current: 99}, level1: {max: 2, current: 2} }`
- ‚úÖ Spell slots checked in `actions.ts` (line 69): `if (slots.level1.current > 0)`
- ‚ùå **Spell slots NEVER decremented** when casting spells in `combat.ts`

### Implementation

**File:** `src/utils/combat.ts` (around line 385)

In the `cast_spell` action handler, add spell slot consumption:

```typescript
} else if (playerAction.type === 'cast_spell') {
  const spellAction = playerAction as CastSpellAction;

  // Find the spell
  const allCantrips = [...WIZARD_CANTRIPS, ...CLERIC_CANTRIPS];
  const spell = allCantrips.find((s) => s.id === spellAction.spellId);

  if (!spell) {
    log.push({
      turn: state.turn,
      actor: 'system',
      message: `Spell not found: ${spellAction.spellId}`,
    });
  } else {
    // NEW: Consume spell slot for non-cantrips
    if (spell.level > 0) {
      if (!playerCharacter.resources.spellSlots) {
        log.push({
          turn: state.turn,
          actor: 'system',
          message: `Cannot cast ${spell.name} - no spell slots available`,
        });
        return state; // Early return
      }

      const slotKey = `level${spell.level}` as keyof typeof playerCharacter.resources.spellSlots;
      const slot = playerCharacter.resources.spellSlots[slotKey];

      if (!slot || slot.current <= 0) {
        log.push({
          turn: state.turn,
          actor: 'system',
          message: `Cannot cast ${spell.name} - no level ${spell.level} slots remaining`,
        });
        return state; // Early return
      }

      // Decrement spell slot
      playerCharacter = {
        ...playerCharacter,
        resources: {
          ...playerCharacter.resources,
          spellSlots: {
            ...playerCharacter.resources.spellSlots,
            [slotKey]: {
              ...slot,
              current: slot.current - 1
            }
          }
        }
      };
    }

    // Cast the spell (existing code continues...)
    const result = castSpell(playerCharacter, enemy, spell);
    // ...
  }
}
```

**Testing:**
1. ‚úÖ Verify cantrips don't consume slots (level 0)
2. ‚úÖ Verify level 1 spells decrement `spellSlots.level1.current`
3. ‚úÖ Verify cannot cast when slots are depleted
4. ‚úÖ Add test in `combat.test.ts` for spell slot consumption

---

## Step 1: Resource System

### Goal

**STATUS: MOSTLY COMPLETE** ‚úÖ - Resources are tracked and functional, but need restoration logic after combat.

### Current Implementation

**ACTUAL ARCHITECTURE** (in `src/types/resource.ts` and `src/types/entity.ts`):

```typescript
// What's actually implemented
export interface Resources {
  abilities: AbilityResource[]; // Second Wind, Dodge, Channel Energy, Turn Undead
  spellSlots?: SpellSlots; // Only for Wizard/Cleric
}

export interface AbilityResource {
  name: string;
  type: 'encounter' | 'daily' | 'at-will';
  maxUses: number;
  currentUses: number;
  description: string;
}

export interface SpellSlots {
  level0: { max: number; current: number }; // Cantrips (99/99 = unlimited)
  level1: { max: number; current: number }; // 2 slots at level 1
}

export interface Entity {
  resources: Resources; // On Entity, inherited by Character
  feats: Feat[]; // Array of Feat objects (not IDs)
  // ... other fields
}
```

**How it's used:**
- **Channel Energy**: Added to `resources.abilities[]` as `{name: 'Channel Energy', type: 'daily', maxUses: 2, currentUses: 2}`
- **Spell Slots**: Added as `resources.spellSlots = {level0: {max: 99, current: 99}, level1: {max: 2, current: 2}}`
- **Feats**: Stored as `Feat[]` array on Entity (basic objects, not feat IDs)

### What Needs to Be Done

#### ‚úÖ Step 1.1: Type Definitions
**Status: COMPLETE** - Resources already defined and working

The existing types are simpler but functional. No changes needed unless you want to refactor to the planned architecture.

#### ‚úÖ Step 1.2: Character Presets
**Status: COMPLETE** - Resources already initialized in `characterCreation.ts`

All classes get appropriate resources:
- Fighter: Second Wind (1/encounter)
- Rogue: Dodge (1/encounter)
- Wizard: Arcane Recovery (1/encounter) + Spell Slots (level0: 99/99, level1: 2/2)
- Cleric: Channel Energy (2/daily) + Turn Undead (3/daily) + Spell Slots (level0: 99/99, level1: 2/2)

#### ‚ùå Step 1.3: Resource Restoration Logic
**Status: NOT IMPLEMENTED** - Critical gap for feat system

**Prerequisites**
- Step 0 complete (spell slot consumption working)

**File:** `src/utils/resources.ts` (NEW FILE - NEEDS CREATION)

```typescript
import type { Character } from '../types/character';
import type { AbilityResource } from '../types/resource';

/**
 * Restore all character resources to maximum
 * Called after combat ends or on long rest
 */
export function restoreResources(character: Character): Character {
  const restored = { ...character };

  // Restore ability resources (Second Wind, Dodge, Channel Energy, Turn Undead)
  const restoredAbilities = character.resources.abilities.map(ability => ({
    ...ability,
    currentUses: ability.maxUses
  }));

  // Restore spell slots
  let restoredSlots = character.resources.spellSlots;
  if (restoredSlots) {
    restoredSlots = {
      level0: { ...restoredSlots.level0, current: restoredSlots.level0.max },
      level1: { ...restoredSlots.level1, current: restoredSlots.level1.max }
    };
  }

  return {
    ...restored,
    resources: {
      abilities: restoredAbilities,
      spellSlots: restoredSlots
    }
  };
}

/**
 * Consume an ability resource (Second Wind, Channel Energy, etc.)
 */
export function consumeAbilityResource(
  character: Character,
  abilityName: string
): Character | null {
  const ability = character.resources.abilities.find(a => a.name === abilityName);

  if (!ability || ability.currentUses <= 0) {
    return null; // Cannot use
  }

  const updatedAbilities = character.resources.abilities.map(a =>
    a.name === abilityName ? { ...a, currentUses: a.currentUses - 1 } : a
  );

  return {
    ...character,
    resources: {
      ...character.resources,
      abilities: updatedAbilities
    }
  };
}

/**
 * Check if ability is available
 */
export function hasAbilityResource(character: Character, abilityName: string): boolean {
  const ability = character.resources.abilities.find(a => a.name === abilityName);
  return ability ? ability.currentUses > 0 || ability.type === 'at-will' : false;
}

/**
 * Consume a spell slot (handled in combat.ts for now, see Step 0)
 * This utility is for when feats need to consume slots (Empower Spell, etc.)
 */
export function consumeSpellSlot(
  character: Character,
  level: 0 | 1
): Character | null {
  if (!character.resources.spellSlots) return null;

  const slotKey = `level${level}` as keyof typeof character.resources.spellSlots;
  const slot = character.resources.spellSlots[slotKey];

  if (!slot || slot.current <= 0) return null;

  return {
    ...character,
    resources: {
      ...character.resources,
      spellSlots: {
        ...character.resources.spellSlots,
        [slotKey]: {
          ...slot,
          current: slot.current - 1
        }
      }
    }
  };
}

/**
 * Check if spell slot is available
 */
export function hasSpellSlot(character: Character, level: 0 | 1): boolean {
  if (!character.resources.spellSlots) return false;
  const slotKey = `level${level}` as keyof typeof character.resources.spellSlots;
  const slot = character.resources.spellSlots[slotKey];
  return slot ? slot.current > 0 : false;
}
```

#### ‚ùå Step 1.4: Resource Display UI Component
**Status: NOT IMPLEMENTED** - Would be nice to have but not blocking

**Prerequisites**
- Step 1.3 complete (resource restoration logic)

**File:** `src/components/ResourceDisplay.tsx` (NEW FILE - OPTIONAL)

**Note:** Resources are currently displayed inline in CharacterSheetScreen (src/screens/CharacterSheetScreen.tsx lines 483-514 for spell slots). A dedicated component would improve reusability but isn't required for the feat system to work.

```typescript
import React from 'react';
import { Character } from '../types/character';

interface ResourceDisplayProps {
  character: Character;
}

export function ResourceDisplay({ character }: ResourceDisplayProps) {
  const { channel_energy, spell_slots } = character.resources;
  
  return (
    <div className="resource-display">
      {/* Channel Energy (Cleric) */}
      {channel_energy && (
        <div className="resource-item">
          <span className="resource-label">Channel Energy:</span>
          <div className="resource-pips">
            {Array.from({ length: channel_energy.max }).map((_, i) => (
              <span 
                key={i} 
                className={`pip ${i < channel_energy.current ? 'filled' : 'empty'}`}
              >
                ‚óè
              </span>
            ))}
            <span className="resource-count">
              {channel_energy.current}/{channel_energy.max}
            </span>
          </div>
        </div>
      )}
      
      {/* Spell Slots (Wizard) */}
      {spell_slots && (
        <div className="resource-item">
          <span className="resource-label">Spell Slots:</span>
          <div className="spell-slots">
            {Object.entries(spell_slots).map(([level, slot]) => {
              if (slot.max <= 0) return null;
              const levelNum = level.replace('level_', '');
              
              return (
                <div key={level} className="spell-slot-level">
                  <span className="level-label">L{levelNum}:</span>
                  <div className="resource-pips">
                    {Array.from({ length: slot.max }).map((_, i) => (
                      <span 
                        key={i} 
                        className={`pip ${i < slot.current ? 'filled' : 'empty'}`}
                      >
                        ‚óè
                      </span>
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      )}
      
      {/* Spell Buffs (Wizard) */}
      {character.buffs && (
        <div className="active-buffs">
          {character.buffs.empowered && (
            <span className="buff-tag empowered">EMPOWERED</span>
          )}
          {character.buffs.disruptiveSpell && (
            <span className="buff-tag disruptive">DISRUPTIVE</span>
          )}
        </div>
      )}
    </div>
  );
}
```

**File:** `src/index.css` (ADD STYLES)

```css
.resource-display {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
  padding: 0.75rem;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 0.5rem;
}

.resource-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.resource-label {
  font-size: 0.875rem;
  color: #9ca3af;
  min-width: 120px;
}

.resource-pips {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.pip {
  font-size: 1rem;
}

.pip.filled {
  color: #3b82f6;
}

.pip.empty {
  color: #374151;
}

.resource-count {
  margin-left: 0.5rem;
  font-size: 0.75rem;
  color: #6b7280;
}

.spell-slots {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.spell-slot-level {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.level-label {
  font-size: 0.75rem;
  color: #9ca3af;
  min-width: 30px;
}

.active-buffs {
  display: flex;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.buff-tag {
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.75rem;
  font-weight: 600;
}

.buff-tag.empowered {
  background: rgba(239, 68, 68, 0.2);
  color: #ef4444;
  border: 1px solid #ef4444;
}

.buff-tag.disruptive {
  background: rgba(168, 85, 247, 0.2);
  color: #a855f7;
  border: 1px solid #a855f7;
}
```

#### Step 1.5: Integrate Resource Display into Combat Screen

**Prerequisites**
- Step 1.4 complete

**File:** `src/screens/CombatScreen.tsx`

```typescript
import { ResourceDisplay } from '../components/ResourceDisplay';

export function CombatScreen() {
  // ... existing code
  
  return (
    <div className="combat-screen">
      {/* Player Stats */}
      <div className="player-panel">
        <h2>{state.player.name}</h2>
        <p>HP: {state.player.hp}/{state.player.maxHp}</p>
        <p>AC: {state.player.ac}</p>
        
        {/* NEW: Resource Display */}
        <ResourceDisplay character={state.player} />
      </div>
      
      {/* ... rest of UI */}
    </div>
  );
}
```

---

## Step 2: Feat Type Definitions

### Goal

Define TypeScript types for feats and create a comprehensive feat database with all 16 feats.

### Current State

**‚ö†Ô∏è MINIMAL IMPLEMENTATION** - Basic types exist but need major extension

**What's Implemented** (`src/types/feat.ts`):
```typescript
export type FeatName = 'Power Attack' | 'Weapon Focus' | 'Toughness' | 'Improved Initiative' | 'Combat Reflexes';

export interface Feat {
  name: FeatName;
  description: string;
  effect: FeatEffect;
}

export type FeatEffect =
  | { type: 'toggle'; name: 'powerAttack' }
  | { type: 'passive'; stat: 'attack' | 'hp' | 'initiative'; bonus: number }
  | { type: 'conditional'; condition: 'dodge'; stat: 'ac'; bonus: number };
```

**Problems:**
- Only 5 feats defined (need 16)
- No feat IDs (uses FeatName enum instead)
- No prerequisites system
- No resource costs (can't implement Channel Smite, Empower Spell, etc.)
- No attack variants (Power Attack is hardcoded in combat.ts)
- Effects are too simple (no damage multipliers, conditions, etc.)

### Implementation Order

#### ‚ùå Step 2.1: Extend Feat Type Definitions
**Status: NEEDS REFACTORING**

**Prerequisites**
- Step 1.3 complete (resource utilities exist)

**File:** `src/types/feat.ts` (EXTEND EXISTING)

```typescript
import { CharacterClass } from './character';
import { ConditionType } from './condition';

export type FeatCategory = 'offensive' | 'defensive' | 'utility';

export type FeatType = 
  | 'attack_variant'   // Shows in attack selector (Power Attack, Guided Hand)
  | 'passive'          // Always active (Weapon Finesse, Critical Focus)
  | 'ability';         // Use Ability action (Empower Spell, Defensive Channel)

export interface FeatPrerequisites {
  bab?: number;
  attributes?: { [key: string]: number };
  feats?: string[]; // IDs of required feats
  classRestrictions?: CharacterClass[];
}

export interface ResourceCost {
  type: 'channel_energy' | 'spell_slot';
  amount: number;
  level?: number; // For spell_slot only
}

export interface FeatEffects {
  // Attack modifiers
  attackModifier?: number;
  damageModifier?: number;
  acModifier?: number;
  
  // Special damage
  bonusDamage?: string; // e.g., "2d6"
  damageType?: string; // e.g., "holy"
  bleedDamage?: string; // e.g., "1d4"
  
  // Stat swaps
  useWisdomForAttack?: boolean; // Guided Hand
  useDexForAttack?: boolean; // Weapon Finesse
  addDexToDamage?: boolean; // Precision Strike
  
  // Damage multipliers
  damageMultiplier?: number; // Vital Strike (2x), Empower Spell (1.5x)
  spellDamageMultiplier?: number; // Only applies to spells
  
  // Critical hit bonuses
  criticalThreatRangeBonus?: number; // Critical Focus (+1)
  
  // Conditions
  appliesCondition?: ConditionType;
  conditionDuration?: number; // In turns
  conditionEffect?: {
    attackPenalty?: number;
    damagePerTurn?: string;
  };
  
  // Resource costs
  consumesResource?: ResourceCost;
  
  // Buff management
  setsState?: 'empowered' | 'disruptiveSpell'; // For wizard abilities
  
  // Duration
  duration: 'turn' | 'nextTurn' | 'nextSpell' | 'nextAttack' | 'permanent';
}

export interface Feat {
  id: string;
  name: string;
  description: string;
  category: FeatCategory;
  type: FeatType;
  prerequisites: FeatPrerequisites;
  effects: FeatEffects;
}
```

#### Step 2.2: Create Feat Database

**Prerequisites**
- Step 2.1 complete

**File:** `src/data/feats.ts` (NEW FILE)

```typescript
import { Feat } from '../types/feat';

export const FEATS: Record<string, Feat> = {
  // ========================================
  // FIGHTER FEATS
  // ========================================
  
  power_attack: {
    id: 'power_attack',
    name: 'Power Attack',
    description: 'Trade accuracy for devastating damage. -2 attack, +4 damage.',
    category: 'offensive',
    type: 'attack_variant',
    prerequisites: {
      attributes: { STR: 13 },
      classRestrictions: ['Fighter', 'Cleric']
    },
    effects: {
      attackModifier: -2,
      damageModifier: 4,
      duration: 'turn'
    }
  },
  
  vital_strike: {
    id: 'vital_strike',
    name: 'Vital Strike',
    description: 'Make one devastating strike, rolling weapon damage dice twice.',
    category: 'offensive',
    type: 'attack_variant',
    prerequisites: {
      bab: 6,
      classRestrictions: ['Fighter']
    },
    effects: {
      damageMultiplier: 2, // Roll weapon dice twice, add modifiers once
      duration: 'turn'
    }
  },
  
  bloody_assault: {
    id: 'bloody_assault',
    name: 'Bloody Assault',
    description: 'Savage strike that causes ongoing bleeding. -2 attack, applies 1d4 bleed.',
    category: 'offensive',
    type: 'attack_variant',
    prerequisites: {
      feats: ['power_attack'],
      bab: 6,
      classRestrictions: ['Fighter']
    },
    effects: {
      attackModifier: -2,
      bleedDamage: '1d4',
      appliesCondition: 'bleeding',
      conditionDuration: 3,
      conditionEffect: {
        damagePerTurn: '1d4'
      },
      duration: 'turn'
    }
  },
  
  combat_expertise: {
    id: 'combat_expertise',
    name: 'Combat Expertise',
    description: 'Trade attack accuracy for improved defense. -2 attack, +2 AC.',
    category: 'defensive',
    type: 'attack_variant',
    prerequisites: {
      attributes: { INT: 13 }
    },
    effects: {
      attackModifier: -2,
      acModifier: 2,
      duration: 'turn'
    }
  },
  
  // ========================================
  // ROGUE FEATS
  // ========================================
  
  weapon_finesse: {
    id: 'weapon_finesse',
    name: 'Weapon Finesse',
    description: 'Use DEX instead of STR for attack rolls with light weapons.',
    category: 'utility',
    type: 'passive',
    prerequisites: {
      classRestrictions: ['Rogue']
    },
    effects: {
      useDexForAttack: true,
      duration: 'permanent'
    }
  },
  
  precision_strike: {
    id: 'precision_strike',
    name: 'Precision Strike',
    description: 'Strike with deadly accuracy. Add DEX modifier to damage (in addition to STR).',
    category: 'offensive',
    type: 'passive',
    prerequisites: {
      bab: 3,
      classRestrictions: ['Rogue']
    },
    effects: {
      addDexToDamage: true,
      duration: 'permanent'
    }
  },
  
  critical_focus: {
    id: 'critical_focus',
    name: 'Critical Focus',
    description: 'You know where to strike. Critical threat range increased by 1 (20 ‚Üí 19-20).',
    category: 'offensive',
    type: 'passive',
    prerequisites: {
      bab: 5,
      classRestrictions: ['Rogue']
    },
    effects: {
      criticalThreatRangeBonus: 1,
      duration: 'permanent'
    }
  },
  
  // ========================================
  // WIZARD FEATS
  // ========================================
  
  arcane_strike: {
    id: 'arcane_strike',
    name: 'Arcane Strike',
    description: 'Channel arcane power into your weapon. +1 damage, weapons count as magic.',
    category: 'utility',
    type: 'passive',
    prerequisites: {
      classRestrictions: ['Wizard']
    },
    effects: {
      damageModifier: 1,
      duration: 'permanent'
    }
  },
  
  empower_spell: {
    id: 'empower_spell',
    name: 'Empower Spell',
    description: 'Supercharge your magic. Next spell deals +50% damage. Consumes 1st-level spell slot.',
    category: 'offensive',
    type: 'ability',
    prerequisites: {
      classRestrictions: ['Wizard']
    },
    effects: {
      setsState: 'empowered',
      spellDamageMultiplier: 1.5,
      consumesResource: {
        type: 'spell_slot',
        amount: 1,
        level: 1
      },
      duration: 'nextSpell'
    }
  },
  
  disruptive_spell: {
    id: 'disruptive_spell',
    name: 'Disruptive Spell',
    description: 'Weave disruption into magic. Next spell applies -4 attack penalty. Consumes 1st-level slot.',
    category: 'offensive',
    type: 'ability',
    prerequisites: {
      bab: 3,
      classRestrictions: ['Wizard']
    },
    effects: {
      setsState: 'disruptiveSpell',
      appliesCondition: 'disrupted',
      conditionDuration: 1,
      conditionEffect: {
        attackPenalty: -4
      },
      consumesResource: {
        type: 'spell_slot',
        amount: 1,
        level: 1
      },
      duration: 'nextSpell'
    }
  },
  
  // ========================================
  // CLERIC FEATS
  // ========================================
  
  guided_hand: {
    id: 'guided_hand',
    name: 'Guided Hand',
    description: 'Channel divine power through your weapon. Use WIS instead of STR for attack rolls.',
    category: 'offensive',
    type: 'attack_variant',
    prerequisites: {
      classRestrictions: ['Cleric']
    },
    effects: {
      useWisdomForAttack: true,
      duration: 'turn'
    }
  },
  
  channel_smite: {
    id: 'channel_smite',
    name: 'Channel Smite',
    description: 'Infuse weapon with holy energy. Add +2d6 damage. Consumes 1 Channel Energy.',
    category: 'offensive',
    type: 'attack_variant',
    prerequisites: {
      bab: 3,
      classRestrictions: ['Cleric']
    },
    effects: {
      bonusDamage: '2d6',
      damageType: 'holy',
      consumesResource: {
        type: 'channel_energy',
        amount: 1
      },
      duration: 'turn'
    }
  },
  
  defensive_channel: {
    id: 'defensive_channel',
    name: 'Defensive Channel',
    description: 'Channel divine protection. Gain +4 AC until next turn. Consumes 1 Channel Energy.',
    category: 'defensive',
    type: 'ability',
    prerequisites: {
      bab: 3,
      classRestrictions: ['Cleric']
    },
    effects: {
      acModifier: 4,
      appliesCondition: 'defensive_channel',
      conditionDuration: 1,
      consumesResource: {
        type: 'channel_energy',
        amount: 1
      },
      duration: 'nextTurn'
    }
  }
};

/**
 * Get all feats available to a character class
 */
export function getFeatsByClass(characterClass: CharacterClass): Feat[] {
  return Object.values(FEATS).filter(feat => {
    if (!feat.prerequisites.classRestrictions) return true;
    return feat.prerequisites.classRestrictions.includes(characterClass);
  });
}

/**
 * Get attack variant feats (shown in attack selector)
 */
export function getAttackVariants(feats: string[]): Feat[] {
  return feats
    .map(id => FEATS[id])
    .filter(feat => feat && feat.type === 'attack_variant');
}

/**
 * Get ability feats (shown in Use Ability section)
 */
export function getAbilityFeats(feats: string[]): Feat[] {
  return feats
    .map(id => FEATS[id])
    .filter(feat => feat && feat.type === 'ability');
}

/**
 * Get passive feats (always active)
 */
export function getPassiveFeats(feats: string[]): Feat[] {
  return feats
    .map(id => FEATS[id])
    .filter(feat => feat && feat.type === 'passive');
}
```

#### Step 2.3: Update Condition Types

**Prerequisites**
- None

**File:** `src/types/condition.ts`

Add new condition types:

```typescript
export type ConditionType = 
  | 'stunned'
  | 'poisoned'
  | 'burning'
  | 'dodge'
  | 'divine_favor'
  | 'resistance'
  | 'off_balance'
  | 'bleeding'           // NEW - Bloody Assault
  | 'defensive_channel'  // NEW - Defensive Channel
  | 'disrupted';         // NEW - Disruptive Spell
```

**File:** `src/utils/conditions.ts`

Add condition definitions:

```typescript
export function getConditionDefinition(type: ConditionType): Omit<Condition, 'duration'> {
  const definitions: Record<ConditionType, Omit<Condition, 'duration'>> = {
    // ... existing conditions
    
    bleeding: {
      type: 'bleeding',
      effect: {
        damagePerTurn: '1d4'
      }
    },
    
    defensive_channel: {
      type: 'defensive_channel',
      effect: {
        acModifier: 4
      }
    },
    
    disrupted: {
      type: 'disrupted',
      effect: {
        attackModifier: -4
      }
    }
  };
  
  return definitions[type];
}
```

---

## Step 3: Combat Integration

### Goal

Update combat resolution to handle attack variants, passive bonuses, abilities, and resource consumption.

### Implementation Order

#### Step 3.1: Extend Action Types

**Prerequisites**
- Step 2.1 complete

**File:** `src/types/action.ts`

```typescript
export type AttackVariant = 
  | 'standard'
  | 'power_attack'
  | 'vital_strike'
  | 'bloody_assault'
  | 'combat_expertise'
  | 'guided_hand'
  | 'channel_smite';

export interface AttackAction {
  type: 'attack';
  variant: AttackVariant;
  targetId: string;
}

export interface UseAbilityAction {
  type: 'use_ability';
  abilityId: string; // Can be class ability OR feat ability
}

// Update PlayerAction union
export type PlayerAction = 
  | AttackAction
  | UseAbilityAction
  | CastSpellAction
  | UseItemAction;
```

#### Step 3.2: Create Feat Utility Functions

**Prerequisites**
- Step 2.2 complete

**File:** `src/utils/feats.ts` (NEW FILE)

```typescript
import { Character } from '../types/character';
import { Feat } from '../types/feat';
import { FEATS } from '../data/feats';
import { hasResource } from './resources';

/**
 * Check if character meets feat prerequisites
 */
export function meetsPrerequisites(feat: Feat, character: Character): boolean {
  const { prerequisites } = feat;
  
  // Check BAB
  if (prerequisites.bab && character.bab < prerequisites.bab) {
    return false;
  }
  
  // Check attributes
  if (prerequisites.attributes) {
    for (const [attr, required] of Object.entries(prerequisites.attributes)) {
      if (character.attributes[attr] < required) {
        return false;
      }
    }
  }
  
  // Check required feats
  if (prerequisites.feats) {
    for (const requiredFeat of prerequisites.feats) {
      if (!character.feats.known.includes(requiredFeat)) {
        return false;
      }
    }
  }
  
  // Check class restrictions
  if (prerequisites.classRestrictions) {
    if (!prerequisites.classRestrictions.includes(character.class)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Check if feat can be used (has resources available)
 */
export function canUseFeat(feat: Feat, character: Character): boolean {
  // Check prerequisites first
  if (!meetsPrerequisites(feat, character)) {
    return false;
  }
  
  // Check resource availability
  if (feat.effects.consumesResource) {
    const { type, level } = feat.effects.consumesResource;
    return hasResource(character, type, level);
  }
  
  return true;
}

/**
 * Get all passive bonuses from character's feats
 */
export function getPassiveBonuses(character: Character) {
  const passives = character.feats.known
    .map(id => FEATS[id])
    .filter(feat => feat && feat.type === 'passive');
  
  const bonuses = {
    attackModifier: 0,
    damageModifier: 0,
    acModifier: 0,
    criticalRangeBonus: 0,
    useDexForAttack: false,
    addDexToDamage: false,
    useWisdomForAttack: false
  };
  
  for (const feat of passives) {
    if (feat.effects.attackModifier) {
      bonuses.attackModifier += feat.effects.attackModifier;
    }
    if (feat.effects.damageModifier) {
      bonuses.damageModifier += feat.effects.damageModifier;
    }
    if (feat.effects.acModifier) {
      bonuses.acModifier += feat.effects.acModifier;
    }
    if (feat.effects.criticalThreatRangeBonus) {
      bonuses.criticalRangeBonus += feat.effects.criticalThreatRangeBonus;
    }
    if (feat.effects.useDexForAttack) {
      bonuses.useDexForAttack = true;
    }
    if (feat.effects.addDexToDamage) {
      bonuses.addDexToDamage = true;
    }
    if (feat.effects.useWisdomForAttack) {
      bonuses.useWisdomForAttack = true;
    }
  }
  
  return bonuses;
}
```

#### Step 3.3: Update Attack Resolution

**Prerequisites**
- Step 3.1-3.2 complete

**File:** `src/utils/combat.ts`

Update `performAttack` function to handle feat variants:

```typescript
import { FEATS } from '../data/feats';
import { getPassiveBonuses } from './feats';
import { consumeResource } from './resources';
import { getAttributeModifier } from './attributes';

export function performAttack(
  attacker: Entity,
  defender: Entity,
  variant: AttackVariant = 'standard'
): AttackResult {
  // Get feat if variant is not standard
  const feat = variant !== 'standard' ? FEATS[variant] : null;
  
  // Get passive bonuses
  const passives = getPassiveBonuses(attacker as Character);
  
  // Calculate base attack bonus
  let attackBonus = attacker.bab;
  let damageBonus = 0;
  let acModifier = 0;
  
  // Determine which ability modifier to use for attack
  let attackAbilityMod = getAttributeModifier(attacker.attributes.STR);
  
  // Passive: Weapon Finesse (use DEX for attack)
  if (passives.useDexForAttack) {
    attackAbilityMod = getAttributeModifier(attacker.attributes.DEX);
  }
  
  // Feat variant: Guided Hand (use WIS for attack)
  if (feat?.effects.useWisdomForAttack) {
    attackAbilityMod = getAttributeModifier(attacker.attributes.WIS);
  }
  
  attackBonus += attackAbilityMod;
  
  // Damage uses STR by default
  damageBonus = getAttributeModifier(attacker.attributes.STR);
  
  // Passive: Precision Strike (add DEX to damage)
  if (passives.addDexToDamage) {
    damageBonus += getAttributeModifier(attacker.attributes.DEX);
  }
  
  // Apply feat modifiers
  if (feat) {
    attackBonus += feat.effects.attackModifier || 0;
    damageBonus += feat.effects.damageModifier || 0;
    acModifier += feat.effects.acModifier || 0;
  }
  
  // Apply passive bonuses
  attackBonus += passives.attackModifier;
  damageBonus += passives.damageModifier;
  acModifier += passives.acModifier;
  
  // Roll attack
  const attackRoll = rollAttack(attackBonus);
  
  // Check for critical hit (considering Critical Focus)
  const baseThreatRange = 20; // Standard weapons crit on natural 20
  const adjustedThreatRange = baseThreatRange - passives.criticalRangeBonus;
  const isThreat = attackRoll.natural >= adjustedThreatRange;
  const isCritical = isThreat && attackRoll.total >= defender.ac;
  
  // Check if hit
  const hits = attackRoll.total >= defender.ac;
  
  if (!hits && !isCritical) {
    return {
      hit: false,
      critical: false,
      attackRoll,
      damage: 0,
      acModifier,
      variant,
      message: `${attackRoll.output} vs AC ${defender.ac} - MISS!`
    };
  }
  
  // Calculate damage
  let damage = 0;
  let damageRolls: DiceRoll[] = [];
  const weaponDice = attacker.equipment.mainHand?.damage || '1d8';
  
  // Vital Strike: Roll weapon dice multiple times
  if (feat?.effects.damageMultiplier) {
    const multiplier = feat.effects.damageMultiplier;
    for (let i = 0; i < multiplier; i++) {
      const diceRoll = roll(weaponDice);
      damageRolls.push(diceRoll);
      damage += diceRoll.total;
    }
    damage += damageBonus; // Add modifiers once
    
    const diceOutput = damageRolls.map(r => `[${r.result}]`).join(' + ');
    return {
      hit: true,
      critical: isCritical,
      attackRoll,
      damage: isCritical ? damage * 2 : damage,
      damageRolls,
      acModifier,
      variant,
      message: `${feat.name}! ${weaponDice} x${multiplier}: ${diceOutput} + ${damageBonus} = ${damage} damage`
    };
  }
  
  // Standard damage roll
  const weaponDamage = rollDamage(weaponDice, damageBonus);
  damage = weaponDamage.total;
  
  // Add bonus damage (Channel Smite)
  if (feat?.effects.bonusDamage) {
    const bonusRoll = roll(feat.effects.bonusDamage);
    damage += bonusRoll.total;
    
    return {
      hit: true,
      critical: isCritical,
      attackRoll,
      damage: isCritical ? damage * 2 : damage,
      acModifier,
      variant,
      applyCondition: feat.effects.appliesCondition ? {
        type: feat.effects.appliesCondition,
        duration: feat.effects.conditionDuration || 1
      } : undefined,
      message: `${feat.name}! ${weaponDamage.output} + ${feat.effects.bonusDamage}: [${bonusRoll.result}] = ${damage} damage`
    };
  }
  
  // Bloody Assault: Apply bleed condition
  if (feat?.effects.bleedDamage) {
    return {
      hit: true,
      critical: isCritical,
      attackRoll,
      damage: isCritical ? damage * 2 : damage,
      acModifier,
      variant,
      applyCondition: {
        type: 'bleeding',
        duration: feat.effects.conditionDuration || 3
      },
      message: `${feat.name}! ${weaponDamage.output} = ${damage} damage + BLEEDING (${feat.effects.bleedDamage})`
    };
  }
  
  // Standard hit
  return {
    hit: true,
    critical: isCritical,
    attackRoll,
    damage: isCritical ? damage * 2 : damage,
    acModifier,
    variant,
    message: weaponDamage.output
  };
}
```

#### Step 3.4: Update Combat Resolution for Abilities

**Prerequisites**
- Step 3.3 complete

**File:** `src/utils/combat.ts`

Update `resolveCombatRound` to handle feat abilities:

```typescript
export function resolveCombatRound(
  state: CombatState,
  playerAction: PlayerAction
): CombatState {
  let newState = { ...state };
  const log: CombatLogEntry[] = [...state.log];
  
  // Handle player action
  if (playerAction.type === 'attack') {
    const attackAction = playerAction as AttackAction;
    const feat = attackAction.variant !== 'standard' ? FEATS[attackAction.variant] : null;
    
    // Consume resources if feat requires it
    if (feat?.effects.consumesResource) {
      const { type, level } = feat.effects.consumesResource;
      const updated = consumeResource(newState.player, type, level);
      if (!updated) {
        // Failed to consume resource - invalid action
        log.push({
          actor: 'system',
          message: `Cannot use ${feat.name} - insufficient resources`,
          timestamp: Date.now()
        });
        return { ...newState, log };
      }
      newState.player = updated;
    }
    
    // Perform attack
    const attackResult = performAttack(
      newState.player,
      newState.enemy,
      attackAction.variant
    );
    
    // Apply damage
    if (attackResult.hit) {
      newState.enemy.hp -= attackResult.damage;
      
      // Apply condition if feat has one
      if (attackResult.applyCondition) {
        newState.enemy.conditions = newState.enemy.conditions || [];
        newState.enemy.conditions.push({
          ...getConditionDefinition(attackResult.applyCondition.type),
          duration: attackResult.applyCondition.duration
        });
      }
    }
    
    // Apply AC modifier to player if feat has one
    if (attackResult.acModifier !== 0) {
      newState.player.conditions = newState.player.conditions || [];
      if (attackResult.acModifier > 0) {
        // Defensive feat
        newState.player.conditions.push({
          type: 'defensive_channel',
          effect: { acModifier: attackResult.acModifier },
          duration: 1
        });
      } else {
        // Offensive feat with AC penalty (Lunge, Power Attack with CE)
        newState.player.conditions.push({
          type: 'off_balance',
          effect: { acModifier: attackResult.acModifier },
          duration: 1
        });
      }
    }
    
    log.push({
      actor: 'player',
      message: attackResult.message,
      timestamp: Date.now()
    });
  }
  
  if (playerAction.type === 'use_ability') {
    const abilityAction = playerAction as UseAbilityAction;
    
    // Check if it's a feat ability
    const feat = FEATS[abilityAction.abilityId];
    if (feat && feat.type === 'ability') {
      // Consume resources
      if (feat.effects.consumesResource) {
        const { type, level } = feat.effects.consumesResource;
        const updated = consumeResource(newState.player, type, level);
        if (!updated) {
          log.push({
            actor: 'system',
            message: `Cannot use ${feat.name} - insufficient resources`,
            timestamp: Date.now()
          });
          return { ...newState, log };
        }
        newState.player = updated;
      }
      
      // Apply effects
      if (feat.id === 'defensive_channel') {
        // Apply AC buff
        newState.player.conditions = newState.player.conditions || [];
        newState.player.conditions.push({
          type: 'defensive_channel',
          effect: { acModifier: 4 },
          duration: 1
        });
        
        log.push({
          actor: 'player',
          message: `${feat.name} activated! +4 AC until next turn`,
          timestamp: Date.now()
        });
      }
      
      if (feat.id === 'empower_spell') {
        // Set empowered buff
        newState.player.buffs = newState.player.buffs || {};
        newState.player.buffs.empowered = true;
        
        log.push({
          actor: 'player',
          message: `${feat.name} activated! Next spell +50% damage`,
          timestamp: Date.now()
        });
      }
      
      if (feat.id === 'disruptive_spell') {
        // Set disruptive buff
        newState.player.buffs = newState.player.buffs || {};
        newState.player.buffs.disruptiveSpell = true;
        
        log.push({
          actor: 'player',
          message: `${feat.name} activated! Next spell applies -4 attack`,
          timestamp: Date.now()
        });
      }
    } else {
      // Handle existing class abilities (Second Wind, Dodge, Channel Energy heal)
      // ... existing ability code
    }
  }
  
  if (playerAction.type === 'cast_spell') {
    const spellAction = playerAction as CastSpellAction;
    
    // Check for spell buffs
    const isEmpowered = newState.player.buffs?.empowered || false;
    const isDisruptive = newState.player.buffs?.disruptiveSpell || false;
    
    // Cast spell (existing logic)
    const spellResult = castSpell(
      newState.player,
      newState.enemy,
      spellAction.spellId
    );
    
    // Apply empower multiplier
    if (isEmpowered && spellResult.damage) {
      spellResult.damage = Math.floor(spellResult.damage * 1.5);
      log.push({
        actor: 'player',
        message: `EMPOWERED! ${spellResult.message} (√ó1.5)`,
        timestamp: Date.now()
      });
      
      // Clear buff
      newState.player.buffs!.empowered = false;
    } else {
      log.push({
        actor: 'player',
        message: spellResult.message,
        timestamp: Date.now()
      });
    }
    
    // Apply disruption
    if (isDisruptive && spellResult.hit) {
      newState.enemy.conditions = newState.enemy.conditions || [];
      newState.enemy.conditions.push({
        type: 'disrupted',
        effect: { attackModifier: -4 },
        duration: 1
      });
      
      log.push({
        actor: 'system',
        message: `Enemy disrupted! -4 attack next turn`,
        timestamp: Date.now()
      });
      
      // Clear buff
      newState.player.buffs!.disruptiveSpell = false;
    }
    
    // Apply damage
    if (spellResult.damage) {
      newState.enemy.hp -= spellResult.damage;
    }
  }
  
  // ... rest of existing combat resolution (enemy turn, condition decrements, etc.)
  
  return { ...newState, log };
}
```

---

## Step 4: UI Implementation

### Goal

Add feat selection UI to Combat Screen with attack variants, abilities, and visual indicators.

### Implementation Order

#### Step 4.1: Create Feat Selector Component

**Prerequisites**
- Step 2.2 complete

**File:** `src/components/FeatSelector.tsx` (NEW FILE)

```typescript
import React from 'react';
import { Feat } from '../types/feat';
import { AttackVariant } from '../types/action';
import { Character } from '../types/character';
import { canUseFeat } from '../utils/feats';

interface FeatSelectorProps {
  feats: Feat[];
  selectedVariant: AttackVariant;
  onSelect: (variant: AttackVariant) => void;
  character: Character;
}

export function FeatSelector({ 
  feats, 
  selectedVariant, 
  onSelect,
  character 
}: FeatSelectorProps) {
  return (
    <div className="feat-selector">
      <h3>Attack Type:</h3>
      
      {/* Standard Attack */}
      <button
        className={`feat-option ${selectedVariant === 'standard' ? 'selected' : ''}`}
        onClick={() => onSelect('standard')}
      >
        <span className="feat-name">Standard Attack</span>
        <span className="feat-description">No modifiers</span>
      </button>
      
      {/* Feat Attack Variants */}
      {feats.map(feat => {
        const isAvailable = canUseFeat(feat, character);
        const resourceCost = feat.effects.consumesResource;
        
        return (
          <button
            key={feat.id}
            className={`feat-option ${selectedVariant === feat.id ? 'selected' : ''} ${!isAvailable ? 'disabled' : ''}`}
            onClick={() => isAvailable && onSelect(feat.id as AttackVariant)}
            disabled={!isAvailable}
            data-category={feat.category}
          >
            <div className="feat-header">
              <span className="feat-name">{feat.name}</span>
              {resourceCost && (
                <span className="resource-cost">
                  {resourceCost.type === 'channel_energy' ? '‚ö°' : '‚ú®'}
                  {resourceCost.amount}
                </span>
              )}
            </div>
            <span className="feat-description">{feat.description}</span>
            <FeatEffectSummary feat={feat} />
          </button>
        );
      })}
    </div>
  );
}

function FeatEffectSummary({ feat }: { feat: Feat }) {
  const effects: string[] = [];
  
  if (feat.effects.attackModifier) {
    const sign = feat.effects.attackModifier > 0 ? '+' : '';
    effects.push(`${sign}${feat.effects.attackModifier} ATK`);
  }
  if (feat.effects.damageModifier) {
    effects.push(`+${feat.effects.damageModifier} DMG`);
  }
  if (feat.effects.bonusDamage) {
    effects.push(`+${feat.effects.bonusDamage} DMG`);
  }
  if (feat.effects.acModifier) {
    const sign = feat.effects.acModifier > 0 ? '+' : '';
    effects.push(`${sign}${feat.effects.acModifier} AC`);
  }
  if (feat.effects.damageMultiplier) {
    effects.push(`√ó${feat.effects.damageMultiplier} Dice`);
  }
  if (feat.effects.bleedDamage) {
    effects.push(`${feat.effects.bleedDamage} Bleed`);
  }
  
  if (effects.length === 0) return null;
  
  return (
    <span className="feat-effects">
      {effects.join(' ‚Ä¢ ')}
    </span>
  );
}
```

#### Step 4.2: Create Ability Selector Component

**Prerequisites**
- Step 2.2 complete

**File:** `src/components/AbilitySelector.tsx` (NEW FILE)

```typescript
import React from 'react';
import { Feat } from '../types/feat';
import { Character } from '../types/character';
import { canUseFeat } from '../utils/feats';

interface AbilitySelectorProps {
  abilityFeats: Feat[];
  character: Character;
  onUseAbility: (abilityId: string) => void;
}

export function AbilitySelector({ 
  abilityFeats, 
  character,
  onUseAbility 
}: AbilitySelectorProps) {
  if (abilityFeats.length === 0) return null;
  
  return (
    <div className="ability-selector">
      <h3>Special Abilities:</h3>
      
      {abilityFeats.map(feat => {
        const isAvailable = canUseFeat(feat, character);
        const resourceCost = feat.effects.consumesResource;
        
        return (
          <button
            key={feat.id}
            className={`ability-option ${!isAvailable ? 'disabled' : ''}`}
            onClick={() => isAvailable && onUseAbility(feat.id)}
            disabled={!isAvailable}
            data-category={feat.category}
          >
            <div className="ability-header">
              <span className="ability-name">{feat.name}</span>
              {resourceCost && (
                <span className="resource-cost">
                  {resourceCost.type === 'channel_energy' ? '‚ö°' : '‚ú®'}
                  {resourceCost.amount}
                </span>
              )}
            </div>
            <span className="ability-description">{feat.description}</span>
          </button>
        );
      })}
    </div>
  );
}
```

#### Step 4.3: Update Combat Screen

**Prerequisites**
- Step 4.1-4.2 complete

**File:** `src/screens/CombatScreen.tsx`

```typescript
import { useState } from 'react';
import { useCombatStore } from '../stores/combatStore';
import { ResourceDisplay } from '../components/ResourceDisplay';
import { FeatSelector } from '../components/FeatSelector';
import { AbilitySelector } from '../components/AbilitySelector';
import { getAttackVariants, getAbilityFeats } from '../data/feats';
import { AttackVariant } from '../types/action';

export function CombatScreen() {
  const { state, executeTurn } = useCombatStore();
  const [selectedVariant, setSelectedVariant] = useState<AttackVariant>('standard');
  
  // Get feats by type
  const attackVariants = getAttackVariants(state.player.feats.known);
  const abilityFeats = getAbilityFeats(state.player.feats.known);
  
  const handleAttack = () => {
    executeTurn({
      type: 'attack',
      variant: selectedVariant,
      targetId: state.enemy.id
    });
    
    // Reset to standard after attack
    setSelectedVariant('standard');
  };
  
  const handleAbility = (abilityId: string) => {
    executeTurn({
      type: 'use_ability',
      abilityId
    });
  };
  
  return (
    <div className="combat-screen">
      {/* Player Panel */}
      <div className="player-panel">
        <h2>{state.player.name}</h2>
        <div className="stats">
          <p>HP: {state.player.hp}/{state.player.maxHp}</p>
          <p>AC: {state.player.ac}</p>
          <p>BAB: +{state.player.bab}</p>
        </div>
        
        {/* Resource Display */}
        <ResourceDisplay character={state.player} />
      </div>
      
      {/* Enemy Panel */}
      <div className="enemy-panel">
        <h2>{state.enemy.name}</h2>
        <div className="stats">
          <p>HP: {state.enemy.hp}/{state.enemy.maxHp}</p>
          <p>AC: {state.enemy.ac}</p>
        </div>
      </div>
      
      {/* Combat Actions */}
      <div className="combat-actions">
        {/* Attack Section */}
        <FeatSelector
          feats={attackVariants}
          selectedVariant={selectedVariant}
          onSelect={setSelectedVariant}
          character={state.player}
        />
        
        <button
          className="action-button attack"
          onClick={handleAttack}
          disabled={state.winner !== null}
        >
          {selectedVariant === 'standard' ? 'Attack' : `Use ${selectedVariant}`}
        </button>
        
        {/* Ability Section */}
        {abilityFeats.length > 0 && (
          <AbilitySelector
            abilityFeats={abilityFeats}
            character={state.player}
            onUseAbility={handleAbility}
          />
        )}
        
        {/* Existing spell/item sections */}
      </div>
      
      {/* Combat Log */}
      <div className="combat-log">
        {state.log.map((entry, i) => (
          <div key={i} className={`log-entry ${entry.actor}`}>
            {entry.message}
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### Step 4.4: Add CSS Styles

**Prerequisites**
- Step 4.3 complete

**File:** `src/index.css`

```css
/* Feat Selector */
.feat-selector {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
  padding: 1rem;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 0.5rem;
}

.feat-selector h3 {
  font-size: 0.875rem;
  color: #9ca3af;
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.feat-option {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 0.75rem;
  background: rgba(255, 255, 255, 0.05);
  border: 2px solid transparent;
  border-radius: 0.375rem;
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
}

.feat-option:hover:not(.disabled) {
  background: rgba(255, 255, 255, 0.1);
  border-color: rgba(59, 130, 246, 0.5);
}

.feat-option.selected {
  background: rgba(59, 130, 246, 0.2);
  border-color: rgb(59, 130, 246);
}

.feat-option.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.feat-option[data-category="offensive"] {
  border-left: 3px solid #ef4444;
}

.feat-option[data-category="defensive"] {
  border-left: 3px solid #3b82f6;
}

.feat-option[data-category="utility"] {
  border-left: 3px solid #8b5cf6;
}

.feat-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-bottom: 0.25rem;
}

.feat-name {
  font-weight: 600;
  color: white;
  font-size: 0.875rem;
}

.feat-description {
  font-size: 0.75rem;
  color: #9ca3af;
  margin-bottom: 0.5rem;
  line-height: 1.4;
}

.feat-effects {
  font-size: 0.75rem;
  color: #60a5fa;
  font-weight: 500;
}

.resource-cost {
  display: flex;
  align-items: center;
  gap: 0.25rem;
  font-size: 0.75rem;
  color: #fbbf24;
  background: rgba(251, 191, 36, 0.1);
  padding: 0.125rem 0.375rem;
  border-radius: 0.25rem;
  border: 1px solid rgba(251, 191, 36, 0.3);
}

/* Ability Selector */
.ability-selector {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  margin-bottom: 1rem;
  padding: 1rem;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 0.5rem;
}

.ability-selector h3 {
  font-size: 0.875rem;
  color: #9ca3af;
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.ability-option {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  padding: 0.75rem;
  background: rgba(168, 85, 247, 0.1);
  border: 2px solid rgba(168, 85, 247, 0.3);
  border-radius: 0.375rem;
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
}

.ability-option:hover:not(.disabled) {
  background: rgba(168, 85, 247, 0.2);
  border-color: rgba(168, 85, 247, 0.5);
}

.ability-option.disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ability-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  margin-bottom: 0.25rem;
}

.ability-name {
  font-weight: 600;
  color: white;
  font-size: 0.875rem;
}

.ability-description {
  font-size: 0.75rem;
  color: #9ca3af;
  line-height: 1.4;
}

/* Action Button */
.action-button {
  width: 100%;
  padding: 1rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 0.5rem;
  cursor: pointer;
  transition: all 0.2s;
  border: 2px solid transparent;
}

.action-button.attack {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  color: white;
}

.action-button.attack:hover:not(:disabled) {
  background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
}

.action-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

/* Mobile Responsive */
@media (max-width: 640px) {
  .feat-selector,
  .ability-selector {
    padding: 0.75rem;
  }
  
  .feat-option,
  .ability-option {
    padding: 0.5rem;
  }
  
  .feat-name,
  .ability-name {
    font-size: 0.8125rem;
  }
  
  .feat-description,
  .ability-description {
    font-size: 0.6875rem;
  }
}
```

---

## Step 5: Character Presets

### Goal

Assign appropriate feats to each class in character creation.

### Implementation Order

#### Step 5.1: Update Character Presets with Feats

**Prerequisites**
- All previous steps complete

**File:** `src/data/characterPresets.ts`

```typescript
export const CHARACTER_PRESETS: Record<CharacterClass, Character> = {
  Fighter: {
    // ... existing stats
    resources: {},
    feats: {
      known: ['power_attack', 'vital_strike', 'bloody_assault', 'combat_expertise']
    }
  },
  
  Rogue: {
    // ... existing stats
    resources: {},
    feats: {
      known: ['weapon_finesse', 'precision_strike', 'critical_focus', 'combat_expertise']
    }
  },
  
  Wizard: {
    // ... existing stats
    resources: {
      spell_slots: {
        level_0: { current: -1, max: -1 },
        level_1: { current: 3, max: 3 },
        level_2: { current: 0, max: 0 },
        level_3: { current: 0, max: 0 }
      }
    },
    feats: {
      known: ['arcane_strike', 'empower_spell', 'disruptive_spell', 'combat_expertise']
    },
    buffs: {
      empowered: false,
      disruptiveSpell: false
    }
  },
  
  Cleric: {
    // ... existing stats
    resources: {
      channel_energy: {
        current: 3,
        max: 3
      }
    },
    feats: {
      known: ['power_attack', 'guided_hand', 'channel_smite', 'defensive_channel']
    }
  }
};
```

---

## File Structure & Architecture

### New Files to Create

```
src/
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ feat.ts                    # Feat type definitions
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ feats.ts                   # Feat database (16 feats)
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ resources.ts               # Resource management utilities
‚îÇ   ‚îî‚îÄ‚îÄ feats.ts                   # Feat checking utilities
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ ResourceDisplay.tsx         # Resource/buff UI component
    ‚îú‚îÄ‚îÄ FeatSelector.tsx           # Attack variant selector
    ‚îî‚îÄ‚îÄ AbilitySelector.tsx        # Special ability selector
```

### Files to Modify

```
src/
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ character.ts               # Add resources, feats, buffs
‚îÇ   ‚îú‚îÄ‚îÄ action.ts                  # Add AttackVariant, update actions
‚îÇ   ‚îî‚îÄ‚îÄ condition.ts               # Add new condition types
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ characterPresets.ts        # Add feats to each class
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ combat.ts                  # Update attack/combat resolution
‚îÇ   ‚îî‚îÄ‚îÄ conditions.ts              # Add new condition definitions
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îî‚îÄ‚îÄ CombatScreen.tsx           # Integrate feat UI
‚îî‚îÄ‚îÄ index.css                       # Add feat/ability styles
```

### Architectural Principles

1. **Separation of data and logic** - `/data/feats.ts` holds definitions, `/utils/feats.ts` has calculations
2. **Type safety** - All feats have strict TypeScript types with FeatEffect interfaces
3. **Store-based state** - Combat store manages feat state and resource consumption
4. **Incremental extension** - Extend existing combat flow rather than rewrite
5. **Resource tracking** - Clear separation between permanent feats and consumable resources
6. **Feat stacking** - Attack variants can stack (e.g., Channel Smite + Power Attack)

---

## Testing Strategy

### Automated Unit Tests (Required for All Utils)

Write comprehensive unit tests using Vitest. Tests must be written alongside implementation.

**File:** `src/utils/__tests__/feats.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { meetsPrerequisites, canUseFeat, getPassiveBonuses } from '../feats';
import { FEATS } from '../../data/feats';

describe('Feat Prerequisites', () => {
  it('checks BAB requirements', () => {
    const character = { bab: 3, /* ... */ };
    expect(meetsPrerequisites(FEATS.power_attack, character)).toBe(true);
    expect(meetsPrerequisites(FEATS.vital_strike, character)).toBe(false);
  });
  
  it('checks attribute requirements', () => {
    const character = { 
      attributes: { STR: 13, INT: 10 },
      bab: 1
    };
    expect(meetsPrerequisites(FEATS.power_attack, character)).toBe(true);
    expect(meetsPrerequisites(FEATS.combat_expertise, character)).toBe(false);
  });
  
  it('checks feat chain requirements', () => {
    const character = { 
      bab: 6,
      feats: { known: ['power_attack'] }
    };
    expect(meetsPrerequisites(FEATS.bloody_assault, character)).toBe(true);
    
    const noPrereqChar = { 
      bab: 6,
      feats: { known: [] }
    };
    expect(meetsPrerequisites(FEATS.bloody_assault, noPrereqChar)).toBe(false);
  });
});

describe('Resource Availability', () => {
  it('checks Channel Energy availability', () => {
    const character = {
      resources: { channel_energy: { current: 2, max: 3 } },
      feats: { known: ['channel_smite'] },
      bab: 3,
      class: 'Cleric'
    };
    expect(canUseFeat(FEATS.channel_smite, character)).toBe(true);
    
    const depleted = {
      ...character,
      resources: { channel_energy: { current: 0, max: 3 } }
    };
    expect(canUseFeat(FEATS.channel_smite, depleted)).toBe(false);
  });
});

describe('Passive Bonuses', () => {
  it('aggregates passive feat bonuses', () => {
    const character = {
      feats: {
        known: ['arcane_strike', 'precision_strike']
      },
      attributes: { DEX: 16 } // +3 modifier
    };
    
    const bonuses = getPassiveBonuses(character);
    expect(bonuses.damageModifier).toBe(1); // Arcane Strike
    expect(bonuses.addDexToDamage).toBe(true); // Precision Strike
  });
});
```

**File:** `src/utils/__tests__/resources.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { restoreResources, consumeResource, hasResource } from '../resources';

describe('Resource Restoration', () => {
  it('restores Channel Energy', () => {
    const character = {
      resources: {
        channel_energy: { current: 1, max: 3 }
      }
    };
    
    const restored = restoreResources(character);
    expect(restored.resources.channel_energy.current).toBe(3);
  });
  
  it('restores spell slots', () => {
    const character = {
      resources: {
        spell_slots: {
          level_1: { current: 1, max: 3 },
          level_2: { current: 0, max: 2 }
        }
      }
    };
    
    const restored = restoreResources(character);
    expect(restored.resources.spell_slots.level_1.current).toBe(3);
    expect(restored.resources.spell_slots.level_2.current).toBe(2);
  });
});

describe('Resource Consumption', () => {
  it('consumes Channel Energy', () => {
    const character = {
      resources: {
        channel_energy: { current: 3, max: 3 }
      }
    };
    
    const updated = consumeResource(character, 'channel_energy');
    expect(updated?.resources.channel_energy.current).toBe(2);
  });
  
  it('prevents consumption when depleted', () => {
    const character = {
      resources: {
        channel_energy: { current: 0, max: 3 }
      }
    };
    
    const updated = consumeResource(character, 'channel_energy');
    expect(updated).toBeNull();
  });
});
```

**File:** `src/utils/__tests__/combat.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { performAttack } from '../combat';

describe('Attack Variants', () => {
  it('applies Power Attack modifiers', () => {
    const attacker = {
      bab: 5,
      attributes: { STR: 16 }, // +3
      equipment: { mainHand: { damage: '1d8' } },
      feats: { known: ['power_attack'] }
    };
    
    const defender = { ac: 15 };
    
    // Mock dice to return consistent values
    const result = performAttack(attacker, defender, 'power_attack');
    
    // Attack bonus should be: 5 (BAB) + 3 (STR) - 2 (Power Attack) = +6
    // Damage should include +4 from Power Attack
    expect(result.variant).toBe('power_attack');
  });
  
  it('rolls weapon dice twice for Vital Strike', () => {
    const attacker = {
      bab: 6,
      attributes: { STR: 16 },
      equipment: { mainHand: { damage: '1d8' } },
      feats: { known: ['vital_strike'] }
    };
    
    const defender = { ac: 15 };
    
    const result = performAttack(attacker, defender, 'vital_strike');
    
    expect(result.damageRolls).toHaveLength(2);
    expect(result.variant).toBe('vital_strike');
  });
});
```

### Manual/Integration Tests

**After each step implementation, manually verify:**

#### Step 1 (Resources):
1. ‚úÖ Resources display correctly in UI
2. ‚úÖ Channel Energy shows 3 pips for Cleric
3. ‚úÖ Spell Slots show correct levels for Wizard
4. ‚úÖ Resources restore after combat ends
5. ‚úÖ Buffs display when active (EMPOWERED, DISRUPTIVE)

#### Step 2 (Feats):
1. ‚úÖ All 16 feats defined in database
2. ‚úÖ Feat prerequisites check correctly
3. ‚úÖ getFeatsByClass returns correct feats

#### Step 3 (Combat):
1. ‚úÖ Power Attack applies -2 attack, +4 damage
2. ‚úÖ Vital Strike rolls weapon dice twice
3. ‚úÖ Bloody Assault applies bleed condition
4. ‚úÖ Combat Expertise applies -2 attack, +2 AC
5. ‚úÖ Guided Hand uses WIS for attack rolls
6. ‚úÖ Channel Smite adds 2d6 damage and consumes resource
7. ‚úÖ Defensive Channel grants +4 AC and consumes resource
8. ‚úÖ Weapon Finesse uses DEX for attack
9. ‚úÖ Precision Strike adds DEX to damage
10. ‚úÖ Critical Focus increases crit range
11. ‚úÖ Arcane Strike adds +1 damage
12. ‚úÖ Empower Spell multiplies spell damage by 1.5
13. ‚úÖ Disruptive Spell applies -4 attack penalty
14. ‚úÖ Feats can stack (Channel Smite + Power Attack)
15. ‚úÖ Resources consumed correctly
16. ‚úÖ Spell buffs persist until used

#### Step 4 (UI):
1. ‚úÖ Feat selector displays attack variants
2. ‚úÖ Selected feat highlights correctly
3. ‚úÖ Disabled feats gray out when resources unavailable
4. ‚úÖ Resource costs display correctly
5. ‚úÖ Ability selector shows special abilities
6. ‚úÖ Mobile layout responsive

#### Step 5 (Presets):
1. ‚úÖ Fighter has 4 correct feats
2. ‚úÖ Rogue has 4 correct feats
3. ‚úÖ Wizard has 4 correct feats + spell buffs initialized
4. ‚úÖ Cleric has 4 correct feats + Channel Energy initialized

---

## REVISED Implementation Roadmap (Based on Current State)

### Priority 1: Fix Critical Gaps (1-2 days)
**These must be completed before feat system can work**

1. ‚úÖ **Step 0.1**: Add spell slot consumption in combat.ts
   - Update `cast_spell` handler to decrement spell slots
   - Add error handling for depleted slots
   - Write tests for spell slot consumption

2. ‚úÖ **Step 1.3**: Create `utils/resources.ts`
   - Add `restoreResources()` function
   - Add resource checking utilities
   - Call `restoreResources()` after combat ends in combatStore

### Priority 2: Refactor Feat System (2-3 days)
**Move from hardcoded to dynamic feat handling**

3. ‚úÖ **Step 2.1**: Extend `types/feat.ts`
   - Add feat IDs, prerequisites, resource costs
   - Add comprehensive FeatEffects interface
   - Keep existing basic feats for backward compatibility

4. ‚úÖ **Step 2.2**: Extend `data/feats.ts`
   - Add 11 missing feats to FEATS object
   - Keep existing 5 feats, refactor to new schema
   - Add feat query helpers (by class, by type, etc.)

5. ‚úÖ **Step 3.1-3.2**: Create `utils/feats.ts`
   - Add prerequisite checking
   - Add passive bonus aggregation
   - Add feat availability checking

### Priority 3: Combat Integration (3-4 days)
**Make feats work in combat dynamically**

6. ‚úÖ **Step 3.3**: Refactor `utils/combat.ts::performAttack()`
   - Remove hardcoded Power Attack
   - Apply passive feats to all attacks
   - Apply attack variant modifiers dynamically
   - Handle critical range bonuses (Critical Focus)

7. ‚úÖ **Step 3.4**: Update combat resolution for ability feats
   - Handle Empower Spell (multiply spell damage by 1.5)
   - Handle Disruptive Spell (apply -4 attack condition)
   - Handle Defensive Channel (grant +4 AC)
   - Consume resources when feats are used

### Priority 4: UI and Polish (2-3 days)
**Make feats visible and selectable**

8. ‚úÖ **Step 4.1-4.3**: Create feat UI components
   - FeatSelector for attack variants
   - AbilitySelector for ability feats
   - Integrate into CombatScreen

9. ‚úÖ **Step 5.1**: Update character creation
   - Give all 4 classes their feat sets (not just Fighter)
   - Update characterCreation.ts
   - Update character presets

### Timeline Estimate
- **Sprint 1 (Priority 1)**: 1-2 days - Fix critical bugs
- **Sprint 2 (Priority 2)**: 2-3 days - Refactor feat system
- **Sprint 3 (Priority 3)**: 3-4 days - Combat integration
- **Sprint 4 (Priority 4)**: 2-3 days - UI and polish

**Total**: 8-12 days of focused development

---

## Success Criteria (Revised)

### Minimum Viable Product (MVP)
- [ ] Spell slots consumed when casting spells
- [ ] Resources restore after combat
- [ ] Power Attack works via feat system (not hardcoded)
- [ ] All 16 feats defined in database
- [ ] Passive feats apply automatically (Weapon Finesse, Arcane Strike, etc.)
- [ ] Attack variants selectable in UI (Power Attack, Combat Expertise, etc.)

### Full Feature Set
- [ ] All 16 feats functional in combat
- [ ] Resource-consuming feats work (Channel Smite, Empower Spell, etc.)
- [ ] Feat prerequisites enforced
- [ ] All 4 classes have complete feat sets
- [ ] Feat UI components integrated into CombatScreen
- [ ] Comprehensive unit tests for feat system
- [ ] Manual testing complete for all feat types

### Stretch Goals (Optional)
- [ ] Dedicated ResourceDisplay component
- [ ] Feat tooltips with detailed info
- [ ] Feat animations/visual effects
- [ ] Balance tuning based on playtesting

---

## Quick Summary: What's Done vs. What's Needed

### ‚úÖ Already Working (Don't Need to Change)
- Channel Energy for Cleric (2/day healing)
- Spell slot tracking (displayed in UI)
- Power Attack feat (hardcoded but functional)
- Basic feat types and 5 feat definitions
- Fighter feat selection during character creation
- Resource consumption for abilities (Second Wind, Dodge, etc.)

### ‚ö†Ô∏è Partially Working (Needs Fixing)
- **Spell Slots**: Tracked but NEVER consumed when casting (CRITICAL BUG)
- **Feat System**: Basic types exist but lack IDs, prerequisites, resource costs
- **Power Attack**: Works but hardcoded in combat.ts (not using feat system)

### ‚ùå Not Implemented (Must Build)
1. **Spell slot consumption** - 30 mins to 1 hour
2. **Resource restoration after combat** - 1-2 hours
3. **Extended feat type system** - 2-3 hours
4. **11 missing feat definitions** - 3-4 hours
5. **Feat utilities** (utils/feats.ts, utils/resources.ts) - 2-3 hours
6. **Dynamic combat integration** - 4-6 hours
7. **Feat UI components** - 3-4 hours
8. **Multi-class feat assignment** - 1-2 hours

### Critical Path to MVP
1. Fix spell slot consumption (Step 0)
2. Add resource restoration (Step 1.3)
3. Extend feat types (Step 2.1)
4. Add missing feats (Step 2.2)
5. Create feat utilities (Step 3.1-3.2)
6. Refactor combat to use feat system (Step 3.3-3.4)

**Estimated Time**: 8-12 days of focused development work