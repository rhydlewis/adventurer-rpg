# Phase 2: Narrative System - Implementation Plan

**Date:** 2025-12-11
**Last Updated:** 2025-12-12
**Status:** Pending
**Scope:** Implement the narrative engine, interactive dialogue with skill checks, the Companion system, and Act 1 content.

---

## Overview

This phase builds the non-combat gameplay loop. We implement a node-based story engine that supports narrative flow, NPC dialogue with skill checks, and world state management.

**Key Design Principles:**
1. **Composition over typing** - Nodes trigger effects rather than being typed as COMBAT/PUZZLE
2. **Use existing skill system** - Leverage `SkillName` for checks, not raw attributes
3. **Unified outcome routing** - Single recursive pattern for all choice outcomes
4. **Hierarchical structure** - Campaign → Act → Node for clean organization
5. **Separated state concerns** - Ephemeral conversation vs persistent world state

---

## Step 1: Core Architecture & Data Schema

### Goal
Define data structures for narrative flow, skill checks, requirements, and world state.

### Implementation Order

#### Step 1.1: Requirement System
**Prerequisites:** None
**File:** `src/types/narrative.ts`

Define what conditions gate choice visibility:

```typescript
import type { SkillName, AbilityScore } from './skill';
import type { CharacterClass } from './character';

// Requirements to SEE a choice option
export type Requirement =
  | { type: 'flag'; flag: string; value: boolean }
  | { type: 'item'; itemId: string }
  | { type: 'attribute'; attr: AbilityScore; min: number }
  | { type: 'skill'; skill: SkillName; minRanks: number }
  | { type: 'class'; class: CharacterClass }
  | { type: 'previousChoice'; choiceId: string }
  | { type: 'nodeVisited'; nodeId: string };
```

#### Step 1.2: Choice Outcome System
**Prerequisites:** Step 1.1
**File:** `src/types/narrative.ts`

Unified recursive pattern for all choice routing:

```typescript
// Outcome of selecting a choice - recursive for skill checks
export type ChoiceOutcome =
  | { type: 'goto'; nodeId: string }
  | { type: 'loop' }  // Return to current node (for questions)
  | { type: 'exit' }  // End conversation, return to exploration
  | { type: 'check';
      skill: SkillName;
      dc: number;
      success: ChoiceOutcome;
      failure: ChoiceOutcome };

export interface Choice {
  id: string;
  text: string;                    // Display text, e.g., "Lie to the guard"
  displayText?: string;            // Optional different text for skill checks: "[Intimidate DC 10] Lie"
  requirements?: Requirement[];    // Must pass ALL to see this choice
  outcome: ChoiceOutcome;
}
```

#### Step 1.3: Node Effects System
**Prerequisites:** Step 1.1
**File:** `src/types/narrative.ts`

Effects triggered when entering a node (composition over typing):

```typescript
// Effects triggered when entering a node
export type NodeEffect =
  | { type: 'setFlag'; flag: string; value: boolean }
  | { type: 'giveItem'; itemId: string }
  | { type: 'removeItem'; itemId: string }
  | { type: 'startCombat'; enemyId: string; onVictoryNodeId: string }
  | { type: 'heal'; amount: number | 'full' }
  | { type: 'damage'; amount: number }
  | { type: 'showCompanionHint'; hint: string };

export interface StoryNode {
  id: string;
  title?: string;                  // Optional scene title
  description: string;             // Main narrative text
  speakerName?: string;            // If dialogue, who is speaking
  speakerPortrait?: string;        // Portrait image path
  locationHint?: string;           // For atmosphere: "The tavern is warm and noisy"

  choices: Choice[];

  // Effects triggered when this node is entered
  onEnter?: NodeEffect[];

  // Companion hint available for this node (player must request it)
  companionHint?: string;
}
```

#### Step 1.4: Campaign Hierarchy
**Prerequisites:** Step 1.3
**File:** `src/types/narrative.ts`

Organize content into a clear hierarchy:

```typescript
export interface Act {
  id: string;
  title: string;                   // "Act 1: The Hook"
  description?: string;            // Brief summary
  locationId?: string;             // Primary location for this act
  startingNodeId: string;          // First node when entering this act
  deathNodeId?: string;            // Narrative death scene for permadeath
  nodes: StoryNode[];
}

export interface Campaign {
  id: string;
  title: string;                   // "The Spire of the Lich King"
  description: string;
  companionName: string;           // "The Elder"
  companionDescription: string;    // For UI display
  acts: Act[];
}
```

#### Step 1.5: Log Entry Types
**Prerequisites:** Step 1.2
**File:** `src/types/narrative.ts`

Separate concerns for clean rendering:

```typescript
export type LogEntry =
  | { type: 'narrative'; text: string; speaker?: string }
  | { type: 'playerChoice'; text: string }
  | { type: 'skillCheck';
      skill: SkillName;
      roll: number;
      modifier: number;
      total: number;
      dc: number;
      success: boolean }
  | { type: 'effect'; message: string }  // "You received Rusty Sword"
  | { type: 'companion'; hint: string };
```

#### Step 1.6: State Separation
**Prerequisites:** Step 1.5
**File:** `src/types/narrative.ts`

Clean separation of ephemeral vs persistent state:

```typescript
// Ephemeral - resets when leaving a conversation
export interface ConversationState {
  active: boolean;
  currentNodeId: string;
  visitedChoiceIds: Set<string>;   // Grayed-out choices in THIS conversation
  log: LogEntry[];
}

// Persistent - survives across the campaign
export interface WorldState {
  campaignId: string;
  currentActId: string;
  currentNodeId: string;           // Where player is in the story
  flags: Record<string, boolean>;  // Story flags
  visitedNodeIds: Set<string>;     // All nodes ever visited
  inventory: string[];             // Item IDs
}
```

---

## Step 2: Narrative Store

### Goal
Implement Zustand store managing both world state and conversation state.

### Implementation Order

#### Step 2.1: Store Foundation
**Prerequisites:** Step 1
**File:** `src/stores/narrativeStore.ts`

```typescript
interface NarrativeStore {
  // Persistent state
  world: WorldState | null;

  // Ephemeral conversation state
  conversation: ConversationState | null;

  // Campaign data (loaded)
  campaign: Campaign | null;

  // Actions
  loadCampaign: (campaign: Campaign) => void;
  startCampaign: (campaignId: string) => void;

  enterNode: (nodeId: string) => void;
  selectChoice: (choiceId: string) => void;
  requestCompanionHint: () => void;

  exitConversation: () => void;

  // Helpers
  getCurrentNode: () => StoryNode | null;
  getAvailableChoices: () => Choice[];  // Filtered by requirements
}
```

#### Step 2.2: Requirement Checker
**Prerequisites:** Step 2.1
**File:** `src/utils/narrativeLogic.ts`

```typescript
function checkRequirement(
  req: Requirement,
  world: WorldState,
  player: Character
): boolean;

function checkAllRequirements(
  requirements: Requirement[],
  world: WorldState,
  player: Character
): boolean;

function getAvailableChoices(
  choices: Choice[],
  world: WorldState,
  player: Character
): Choice[];
```

#### Step 2.3: Skill Check Resolver
**Prerequisites:** Step 2.2, existing dice utils
**File:** `src/utils/narrativeLogic.ts`

Uses existing skill system for proper bonus calculation:

```typescript
import { calculateSkillBonus } from './skills';
import { rollD20 } from './dice';

interface SkillCheckResult {
  skill: SkillName;
  roll: number;        // Natural d20 result
  modifier: number;    // Total skill bonus
  total: number;       // roll + modifier
  dc: number;
  success: boolean;
}

function resolveSkillCheck(
  player: Character,
  skill: SkillName,
  dc: number
): SkillCheckResult;
```

#### Step 2.4: Outcome Resolver
**Prerequisites:** Step 2.3
**File:** `src/utils/narrativeLogic.ts`

Recursively resolve choice outcomes:

```typescript
interface OutcomeResolution {
  nextNodeId: string | null;  // null = exit conversation
  logEntries: LogEntry[];
  worldUpdates: Partial<WorldState>;
}

function resolveOutcome(
  outcome: ChoiceOutcome,
  player: Character,
  currentNodeId: string
): OutcomeResolution;
```

#### Step 2.5: Effect Processor
**Prerequisites:** Step 2.4
**File:** `src/utils/narrativeLogic.ts`

Process node entry effects:

```typescript
interface EffectResult {
  logEntries: LogEntry[];
  worldUpdates: Partial<WorldState>;
  combatTrigger?: string;  // Enemy ID if combat should start
}

function processNodeEffects(
  effects: NodeEffect[],
  world: WorldState
): EffectResult;
```

---

## Step 3: Validation & Test Data

### Goal
Create minimal test content to validate the type system before building UI.

#### Step 3.1: Test Campaign Data
**Prerequisites:** Step 1
**File:** `src/data/campaigns/test-campaign.ts`

Create a 4-5 node test campaign exercising all features:
- Simple narrative node with 2 choices
- Dialogue node with skill check (Intimidate DC 10)
- Node with requirements (flag-gated choice)
- Node with effects (set flag, give item)
- Exit node

#### Step 3.2: Unit Tests
**Prerequisites:** Step 2, Step 3.1
**File:** `src/__tests__/utils/narrativeLogic.test.ts`

Test cases:
- `checkRequirement` with each requirement type
- `resolveSkillCheck` with mocked dice (success/failure)
- `resolveOutcome` with nested skill check outcomes
- `processNodeEffects` with flag and item effects

**File:** `src/__tests__/stores/narrativeStore.test.ts`

Test cases:
- Load campaign, verify initial state
- `enterNode` triggers effects and adds to log
- `selectChoice` resolves outcome and updates state
- `exitConversation` resets conversation but preserves world state
- Skill check choice creates proper log entry

---

## Step 4: UI Implementation

### Goal
Build narrative UI components, starting simple and adding polish.

### Implementation Order

#### Step 4.1: Basic Story Screen
**Prerequisites:** Step 2
**File:** `src/screens/StoryScreen.tsx`

Minimal viable narrative display:
- Show current node description
- List available choices as buttons
- Display log entries (scrollable)
- Handle choice selection

#### Step 4.2: Choice Component
**Prerequisites:** Step 4.1
**File:** `src/components/narrative/ChoiceButton.tsx`

Smart choice rendering:
- Normal choices: plain button
- Skill check choices: show `[Skill DC X]` prefix
- Previously selected (this session): grayed out, still clickable for loops
- Requirements not met: hidden (not shown at all)

#### Step 4.3: Narrative Log Component
**Prerequisites:** Step 4.1
**File:** `src/components/narrative/NarrativeLog.tsx`

Render different log entry types:
- `narrative`: Regular text, optional speaker name styling
- `playerChoice`: Indented, different color (shows what player chose)
- `skillCheck`: Dice result formatting with success/failure colors
- `effect`: System message styling
- `companion`: Special styling for hint text

#### Step 4.4: Dialogue View Enhancement
**Prerequisites:** Step 4.3
**File:** `src/components/narrative/DialogueView.tsx`

Enhanced layout for NPC conversations:
- Header: Speaker portrait + name (if `speakerName` set)
- Body: `NarrativeLog` component
- Footer: Choice buttons

Only shown when current node has `speakerName` set.

#### Step 4.5: Companion Integration
**Prerequisites:** Step 4.4
**File:** `src/components/narrative/CompanionHint.tsx`

Contextual companion hint display:
- Show companion icon/button only when `companionHint` exists on current node
- Clicking adds hint to the log as a `companion` entry
- Icon shows "available" state, changes to "viewed" after clicking
- Companion name from campaign data

---

## Step 5: Content Integration

### Goal
Implement "The Spire of the Lich King" Act 1.

#### Step 5.1: Campaign Structure
**Prerequisites:** Step 4
**File:** `src/data/campaigns/campaign-01.ts`

```typescript
export const spireOfTheLichKing: Campaign = {
  id: 'spire-of-the-lich-king',
  title: 'The Spire of the Lich King',
  description: 'Investigate the glowing ruins of the Old Watchtower...',
  companionName: 'The Elder',
  companionDescription: 'A mysterious artifact that offers cryptic guidance.',
  acts: [act1Oakhaven, act2Tower, ...]
};
```

#### Step 5.2: Act 1 - The Hook & The Approach
**Prerequisites:** Step 5.1
**File:** `src/data/campaigns/campaign-01-act1.ts`

Key scenes to implement:

**The Tavern (The Splintered Shield)**
- Opening narrative setting the scene
- Dialogue with terrified Poacher:
  - Basic questions (loop back)
  - `[Intimidate DC 10]` - reveal extra info on success
  - `[Perception DC 12]` - notice he's hiding something
- Magistrate offers bounty (sets `accepted_bounty` flag)

**The Journey**
- Short travel narrative
- Choice: investigate strange sound OR press on
- Combat trigger: Blighted Wolf (uses `startCombat` effect)

**Tower Entrance**
- Describe the sealed barrier
- Companion hint: "The stones... they hum when near the barrier."
- Puzzle choices gated by `has_singing_stone_X` flags
- Success: proceed to Act 2

#### Step 5.3: Wire Up Navigation
**Prerequisites:** Step 5.2
**File:** Updates to `App.tsx` and routing

- Add `StoryScreen` to app navigation
- Connect combat victory/defeat back to narrative
- Handle `startCombat` effect triggering `CombatScreen`
- Return to narrative after combat resolves

---

## File Structure

### New Files

```
src/
├── types/
│   └── narrative.ts           # All narrative type definitions
├── stores/
│   └── narrativeStore.ts      # Narrative + world state management
├── utils/
│   └── narrativeLogic.ts      # Requirements, skill checks, outcomes
├── components/
│   └── narrative/
│       ├── ChoiceButton.tsx   # Smart choice rendering
│       ├── NarrativeLog.tsx   # Log entry display
│       ├── DialogueView.tsx   # NPC conversation layout
│       └── CompanionHint.tsx  # Companion hint button/display
├── screens/
│   └── StoryScreen.tsx        # Main narrative screen
├── data/
│   └── campaigns/
│       ├── test-campaign.ts   # Validation test data
│       ├── campaign-01.ts     # Main campaign definition
│       └── campaign-01-act1.ts # Act 1 nodes
└── __tests__/
    ├── utils/
    │   └── narrativeLogic.test.ts
    └── stores/
        └── narrativeStore.test.ts
```

### Modified Files

- `src/types/index.ts` - Export narrative types
- `src/App.tsx` - Add StoryScreen routing
- `src/stores/combatStore.ts` - Add callback for combat completion

---

## Testing Strategy

### Automated Unit Tests

**`narrativeLogic.test.ts`:**
- Requirement checking (all 7 requirement types)
- Skill check resolution with mocked dice
- Outcome resolution including nested checks
- Effect processing

**`narrativeStore.test.ts`:**
- Campaign loading and initialization
- Node entry with effects
- Choice selection flow
- Conversation exit preserves world state
- Available choices filtered by requirements

### Manual Verification Checklist

1. **Basic Flow:**
   - [ ] Load campaign, see first node
   - [ ] Select choice, see next node
   - [ ] Log updates with narrative and choices

2. **Skill Checks:**
   - [ ] Skill check choice shows `[Skill DC X]` prefix
   - [ ] Selecting triggers dice roll
   - [ ] Log shows roll breakdown
   - [ ] Success/failure routes to correct node

3. **Requirements:**
   - [ ] Choices with unmet requirements are hidden
   - [ ] Gaining a flag reveals previously hidden choice
   - [ ] Class-specific choices only show for correct class

4. **Conversation State:**
   - [ ] Selected choices gray out during conversation
   - [ ] Exiting and re-entering resets grayed choices
   - [ ] World flags persist after exit

5. **Companion:**
   - [ ] Hint button only shows when hint available
   - [ ] Clicking adds hint to log
   - [ ] Shows companion name from campaign

6. **Combat Integration:**
   - [ ] `startCombat` effect launches combat screen
   - [ ] Victory returns to narrative at correct node
   - [ ] Defeat triggers appropriate narrative (or permadeath)

---

## Dependencies

### From Phase 1 (Required)
- `src/types/skill.ts` - `SkillName`, `AbilityScore`
- `src/types/character.ts` - `Character`, `CharacterClass`
- `src/utils/skills.ts` - `calculateSkillBonus`
- `src/utils/dice.ts` - `rollD20`
- `src/stores/characterStore.ts` - Current player character

### New Dependencies
- None required (uses existing Zustand, React)

---

## Design Decisions

1. **Permadeath handling:** Show a narrative death scene before game over. Each act should define a `deathNodeId` that displays appropriate narrative when the player dies.

2. **Save/Load:** Wait for a dedicated save system in a later phase. World state will be kept in memory only during Phase 2.

3. **Combat return point:** Advance to a post-combat node. Combat-triggering effects should specify both `enemyId` and `onVictoryNodeId` to define where the story continues after winning.

---

## Success Criteria

Phase 2 is complete when:
- [ ] Player can progress through Act 1 narrative
- [ ] Skill checks work with proper bonuses and logging
- [ ] Companion hints are accessible
- [ ] Combat triggers from narrative and returns correctly
- [ ] All unit tests pass
- [ ] World state persists across conversations
