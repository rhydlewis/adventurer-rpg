# Phase 2: Narrative System - Implementation Plan

**Date:** 2025-12-11
**Last Updated:** 2025-12-14
**Status:** ~70% Complete - Core engine done, content missing
**Scope:** Implement the narrative engine, interactive dialogue with skill checks, the Companion system, and Act 1 content.

---

## Overview

This phase builds the non-combat gameplay loop. We implement a node-based story engine that supports narrative flow, NPC dialogue with skill checks, and world state management.

**Key Design Principles:**
1. **Composition over typing** - Nodes trigger effects rather than being typed as COMBAT/PUZZLE
2. **Use existing skill system** - Leverage `SkillName` for checks, not raw attributes
3. **Unified outcome routing** - Single recursive pattern for all choice outcomes
4. **Hierarchical structure** - Campaign â†’ Act â†’ Node for clean organization
5. **Separated state concerns** - Ephemeral conversation vs persistent world state

---

## Progress Summary

### âœ… Completed Steps

**Step 1: Core Architecture & Data Schema** âœ… 100% COMPLETE (2025-12-11)
- All type definitions in `types/narrative.ts` (367 lines)
- Requirement system (7 types: flag, item, attribute, skill, class, previousChoice, nodeVisited)
- Choice outcome system (goto, loop, exit, check with recursive skill checks)
- Node effects (setFlag, giveItem, removeItem, startCombat, heal, damage, showCompanionHint)
- Campaign hierarchy (Campaign â†’ Act â†’ StoryNode)
- Log entry types (narrative, playerChoice, skillCheck, effect, companion)
- State separation (ConversationState vs WorldState)

**Step 2: Narrative Store** âœ… 100% COMPLETE (2025-12-11)
- `narrativeStore.ts` - Full store with world/conversation state (329 lines)
- `narrativeLogic.ts` - All utility functions (356 lines)
- Requirement checking (all 7 types)
- Skill check resolution using existing skill system
- Recursive outcome resolution (handles nested checks)
- Effect processing (all 7 effect types)
- Navigation callback integration

**Step 3: Validation & Test Data** âœ… 100% COMPLETE (2025-12-12)
- Test campaign: 18 nodes exercising all features (399 lines)
- 36 unit tests passing (643 lines)
- Comprehensive coverage: requirements, skill checks, outcomes, effects
- All test cases green

**Step 4: UI Implementation** âš ï¸ 70% COMPLETE (2025-12-12)
- âœ… `StoryScreen.tsx` - Main narrative display (226 lines)
- âœ… `ChoiceButton.tsx` - Smart choice rendering (61 lines)
- âœ… `NarrativeLog.tsx` - Log entry display (98 lines)
- âœ… Navigation integration in `App.tsx`
- âš ï¸ DialogueView - Functionality exists inline in StoryScreen (not extracted)
- âš ï¸ CompanionHint - Functionality exists inline in StoryScreen (not extracted)

### ğŸ“‹ Remaining Work

**Step 5: Content Integration** âŒ 0% COMPLETE
- âŒ Campaign 01 data files (`campaign-01.ts`, `campaign-01-act1.ts`)
- âŒ "The Spire of the Lich King" Act 1 content
  - Tavern scene (Poacher dialogue, Magistrate bounty)
  - Journey scene (Blighted Wolf combat)
  - Tower Entrance puzzle
- âŒ `GameOverScreen.tsx` (permadeath screen)
- âŒ `VictoryScreen.tsx` (campaign completion)
- âŒ Combat return flow (victory â†’ story continuation)

**Optional Improvements:**
- âŒ `narrativeStore.test.ts` (store-level unit tests)
- âŒ Extract DialogueView component (currently inline)
- âŒ Extract CompanionHint component (currently inline)

### ğŸ¯ Current Status

**What Works:**
- Complete narrative engine (types, store, logic)
- Test campaign playable end-to-end
- Skill checks with d20 mechanics
- Requirement-based choice gating
- Story flags and world state
- Companion hints
- Combat integration (startCombat effect)
- Inventory system (giveItem/removeItem)

**What's Missing:**
- Production campaign content (Campaign 01)
- Death/victory screens
- Store-level tests (utils fully tested)

---

## Screen Architecture

### Full Game Screen Inventory

| Screen | Status | Phase | Purpose |
|--------|--------|-------|---------|
| **HomeScreen** | Exists | 0 | Main menu (start, continue, settings) |
| **CharacterCreationScreen** | Exists | 1 | Class selection, point buy, naming |
| **CharacterSheetScreen** | Exists | 1 | Stats, equipment, abilities |
| **CombatScreen** | Exists | 1 | Turn-based d20 combat |
| **StoryScreen** | Phase 2 | 2 | Narrative text + choices |
| **GameOverScreen** | Phase 2 | 2 | Permadeath death scene + restart |
| **VictoryScreen** | Phase 2 | 2 | Campaign completion |
| **WorldMapScreen** | Future | 3 | Location selection, travel |
| **RestScreen** | Future | 4 | Short/long rest, camp events |
| **InventoryScreen** | Optional | 4 | Item management (could be CharacterSheet tab) |
| **QuestLogScreen** | Optional | 3 | Active/completed quests (could be modal) |
| **SettingsScreen** | Optional | 6 | Audio, display options |

### Screen Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HomeScreen  â”‚ (Main Menu)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€ New Game â”€â”€â–º CharacterCreationScreen â”€â”€â”
       â”‚                                          â”‚
       â””â”€â”€ Continue â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                                                  â–¼
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚      StoryScreen        â”‚â—„â”€â”€â”€â”€â”€â”€â”
                                    â”‚  (Narrative + Choices)  â”‚       â”‚
                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
                                                 â”‚                    â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                          â”‚                      â”‚                  â”‚ â”‚
                          â–¼                      â–¼                  â–¼ â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚CombatScreenâ”‚      â”‚WorldMapScreenâ”‚    â”‚ RestScreen  â”‚
                   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â”‚   (Phase 3)  â”‚    â”‚  (Phase 4)  â”‚
                         â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚                  â”‚
              â”‚                     â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜
              â–¼                     â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  Victory   â”‚        â”‚ GameOverScr  â”‚
       â”‚ (returns   â”‚        â”‚ (Permadeath) â”‚
       â”‚ to Story)  â”‚        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
                                     â–¼
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚ HomeScreen  â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Navigation State

```typescript
// src/types/navigation.ts
export type Screen =
  | { type: 'home' }
  | { type: 'characterCreation' }
  | { type: 'story' }
  | { type: 'combat'; enemyId: string; onVictoryNodeId: string }
  | { type: 'gameOver'; deathNodeId?: string }
  | { type: 'victory' }
  | { type: 'characterSheet' }
  | { type: 'worldMap' }   // Phase 3
  | { type: 'rest' };      // Phase 4
```

### Overlay/Modal Components

These appear over any screen:

| Component | Purpose |
|-----------|---------|
| **CharacterSheetModal** | Quick stat view during combat/story |
| **InventoryModal** | Item management mid-game |
| **CompanionHintModal** | Display companion advice |
| **PauseMenu** | Settings, quit to menu |
| **ConfirmDialog** | "Are you sure?" prompts |

### Phase 2 Minimum Screens

For Phase 2, we need:
1. **StoryScreen** - Core narrative display (new)
2. **GameOverScreen** - Death scene + return to menu (new)
3. **CombatScreen** - Modify to return to story on victory (update)

---

## Step 1: Core Architecture & Data Schema

### Goal
Define data structures for narrative flow, skill checks, requirements, and world state.

### Implementation Order

#### Step 1.1: Requirement System
**Prerequisites:** None
**File:** `src/types/narrative.ts`

Define what conditions gate choice visibility:

```typescript
import type { SkillName, AbilityScore } from './skill';
import type { CharacterClass } from './character';

// Requirements to SEE a choice option
export type Requirement =
  | { type: 'flag'; flag: string; value: boolean }
  | { type: 'item'; itemId: string }
  | { type: 'attribute'; attr: AbilityScore; min: number }
  | { type: 'skill'; skill: SkillName; minRanks: number }
  | { type: 'class'; class: CharacterClass }
  | { type: 'previousChoice'; choiceId: string }
  | { type: 'nodeVisited'; nodeId: string };
```

#### Step 1.2: Choice Outcome System
**Prerequisites:** Step 1.1
**File:** `src/types/narrative.ts`

Unified recursive pattern for all choice routing:

```typescript
// Outcome of selecting a choice - recursive for skill checks
export type ChoiceOutcome =
  | { type: 'goto'; nodeId: string }
  | { type: 'loop' }  // Return to current node (for questions)
  | { type: 'exit' }  // End conversation, return to exploration
  | { type: 'check';
      skill: SkillName;
      dc: number;
      success: ChoiceOutcome;
      failure: ChoiceOutcome };

export interface Choice {
  id: string;
  text: string;                    // Display text, e.g., "Lie to the guard"
  displayText?: string;            // Optional different text for skill checks: "[Intimidate DC 10] Lie"
  requirements?: Requirement[];    // Must pass ALL to see this choice
  outcome: ChoiceOutcome;
}
```

#### Step 1.3: Node Effects System
**Prerequisites:** Step 1.1
**File:** `src/types/narrative.ts`

Effects triggered when entering a node (composition over typing):

```typescript
// Effects triggered when entering a node
export type NodeEffect =
  | { type: 'setFlag'; flag: string; value: boolean }
  | { type: 'giveItem'; itemId: string }
  | { type: 'removeItem'; itemId: string }
  | { type: 'startCombat'; enemyId: string; onVictoryNodeId: string }
  | { type: 'heal'; amount: number | 'full' }
  | { type: 'damage'; amount: number }
  | { type: 'showCompanionHint'; hint: string };

export interface StoryNode {
  id: string;
  title?: string;                  // Optional scene title
  description: string;             // Main narrative text
  speakerName?: string;            // If dialogue, who is speaking
  speakerPortrait?: string;        // Portrait image path
  locationHint?: string;           // For atmosphere: "The tavern is warm and noisy"

  choices: Choice[];

  // Effects triggered when this node is entered
  onEnter?: NodeEffect[];

  // Companion hint available for this node (player must request it)
  companionHint?: string;
}
```

#### Step 1.4: Campaign Hierarchy
**Prerequisites:** Step 1.3
**File:** `src/types/narrative.ts`

Organize content into a clear hierarchy:

```typescript
export interface Act {
  id: string;
  title: string;                   // "Act 1: The Hook"
  description?: string;            // Brief summary
  locationId?: string;             // Primary location for this act
  startingNodeId: string;          // First node when entering this act
  deathNodeId?: string;            // Narrative death scene for permadeath
  nodes: StoryNode[];
}

export interface Campaign {
  id: string;
  title: string;                   // "The Spire of the Lich King"
  description: string;
  companionName: string;           // "The Elder"
  companionDescription: string;    // For UI display
  acts: Act[];
}
```

#### Step 1.5: Log Entry Types
**Prerequisites:** Step 1.2
**File:** `src/types/narrative.ts`

Separate concerns for clean rendering:

```typescript
export type LogEntry =
  | { type: 'narrative'; text: string; speaker?: string }
  | { type: 'playerChoice'; text: string }
  | { type: 'skillCheck';
      skill: SkillName;
      roll: number;
      modifier: number;
      total: number;
      dc: number;
      success: boolean }
  | { type: 'effect'; message: string }  // "You received Rusty Sword"
  | { type: 'companion'; hint: string };
```

#### Step 1.6: State Separation
**Prerequisites:** Step 1.5
**File:** `src/types/narrative.ts`

Clean separation of ephemeral vs persistent state:

```typescript
// Ephemeral - resets when leaving a conversation
export interface ConversationState {
  active: boolean;
  currentNodeId: string;
  visitedChoiceIds: Set<string>;   // Grayed-out choices in THIS conversation
  log: LogEntry[];
}

// Persistent - survives across the campaign
export interface WorldState {
  campaignId: string;
  currentActId: string;
  currentNodeId: string;           // Where player is in the story
  flags: Record<string, boolean>;  // Story flags
  visitedNodeIds: Set<string>;     // All nodes ever visited
  inventory: string[];             // Item IDs
}
```

---

## Step 2: Narrative Store

### Goal
Implement Zustand store managing both world state and conversation state.

### Implementation Order

#### Step 2.1: Store Foundation
**Prerequisites:** Step 1
**File:** `src/stores/narrativeStore.ts`

```typescript
interface NarrativeStore {
  // Persistent state
  world: WorldState | null;

  // Ephemeral conversation state
  conversation: ConversationState | null;

  // Campaign data (loaded)
  campaign: Campaign | null;

  // Actions
  loadCampaign: (campaign: Campaign) => void;
  startCampaign: (campaignId: string) => void;

  enterNode: (nodeId: string) => void;
  selectChoice: (choiceId: string) => void;
  requestCompanionHint: () => void;

  exitConversation: () => void;

  // Helpers
  getCurrentNode: () => StoryNode | null;
  getAvailableChoices: () => Choice[];  // Filtered by requirements
}
```

#### Step 2.2: Requirement Checker
**Prerequisites:** Step 2.1
**File:** `src/utils/narrativeLogic.ts`

```typescript
function checkRequirement(
  req: Requirement,
  world: WorldState,
  player: Character
): boolean;

function checkAllRequirements(
  requirements: Requirement[],
  world: WorldState,
  player: Character
): boolean;

function getAvailableChoices(
  choices: Choice[],
  world: WorldState,
  player: Character
): Choice[];
```

#### Step 2.3: Skill Check Resolver
**Prerequisites:** Step 2.2, existing dice utils
**File:** `src/utils/narrativeLogic.ts`

Uses existing skill system for proper bonus calculation:

```typescript
import { calculateSkillBonus } from './skills';
import { rollD20 } from './dice';

interface SkillCheckResult {
  skill: SkillName;
  roll: number;        // Natural d20 result
  modifier: number;    // Total skill bonus
  total: number;       // roll + modifier
  dc: number;
  success: boolean;
}

function resolveSkillCheck(
  player: Character,
  skill: SkillName,
  dc: number
): SkillCheckResult;
```

#### Step 2.4: Outcome Resolver
**Prerequisites:** Step 2.3
**File:** `src/utils/narrativeLogic.ts`

Recursively resolve choice outcomes:

```typescript
interface OutcomeResolution {
  nextNodeId: string | null;  // null = exit conversation
  logEntries: LogEntry[];
  worldUpdates: Partial<WorldState>;
}

function resolveOutcome(
  outcome: ChoiceOutcome,
  player: Character,
  currentNodeId: string
): OutcomeResolution;
```

#### Step 2.5: Effect Processor
**Prerequisites:** Step 2.4
**File:** `src/utils/narrativeLogic.ts`

Process node entry effects:

```typescript
interface EffectResult {
  logEntries: LogEntry[];
  worldUpdates: Partial<WorldState>;
  combatTrigger?: string;  // Enemy ID if combat should start
}

function processNodeEffects(
  effects: NodeEffect[],
  world: WorldState
): EffectResult;
```

---

## Step 3: Validation & Test Data

### Goal
Create minimal test content to validate the type system before building UI.

#### Step 3.1: Test Campaign Data
**Prerequisites:** Step 1
**File:** `src/data/campaigns/test-campaign.ts`

Create a 4-5 node test campaign exercising all features:
- Simple narrative node with 2 choices
- Dialogue node with skill check (Intimidate DC 10)
- Node with requirements (flag-gated choice)
- Node with effects (set flag, give item)
- Exit node

#### Step 3.2: Unit Tests
**Prerequisites:** Step 2, Step 3.1
**File:** `src/__tests__/utils/narrativeLogic.test.ts`

Test cases:
- `checkRequirement` with each requirement type
- `resolveSkillCheck` with mocked dice (success/failure)
- `resolveOutcome` with nested skill check outcomes
- `processNodeEffects` with flag and item effects

**File:** `src/__tests__/stores/narrativeStore.test.ts`

Test cases:
- Load campaign, verify initial state
- `enterNode` triggers effects and adds to log
- `selectChoice` resolves outcome and updates state
- `exitConversation` resets conversation but preserves world state
- Skill check choice creates proper log entry

---

## Step 4: UI Implementation

### Goal
Build narrative UI components, starting simple and adding polish.

### Implementation Order

#### Step 4.1: Basic Story Screen
**Prerequisites:** Step 2
**File:** `src/screens/StoryScreen.tsx`

Minimal viable narrative display:
- Show current node description
- List available choices as buttons
- Display log entries (scrollable)
- Handle choice selection

#### Step 4.2: Choice Component
**Prerequisites:** Step 4.1
**File:** `src/components/narrative/ChoiceButton.tsx`

Smart choice rendering:
- Normal choices: plain button
- Skill check choices: show `[Skill DC X]` prefix
- Previously selected (this session): grayed out, still clickable for loops
- Requirements not met: hidden (not shown at all)

#### Step 4.3: Narrative Log Component
**Prerequisites:** Step 4.1
**File:** `src/components/narrative/NarrativeLog.tsx`

Render different log entry types:
- `narrative`: Regular text, optional speaker name styling
- `playerChoice`: Indented, different color (shows what player chose)
- `skillCheck`: Dice result formatting with success/failure colors
- `effect`: System message styling
- `companion`: Special styling for hint text

#### Step 4.4: Dialogue View Enhancement
**Prerequisites:** Step 4.3
**File:** `src/components/narrative/DialogueView.tsx`

Enhanced layout for NPC conversations:
- Header: Speaker portrait + name (if `speakerName` set)
- Body: `NarrativeLog` component
- Footer: Choice buttons

Only shown when current node has `speakerName` set.

#### Step 4.5: Companion Integration
**Prerequisites:** Step 4.4
**File:** `src/components/narrative/CompanionHint.tsx`

Contextual companion hint display:
- Show companion icon/button only when `companionHint` exists on current node
- Clicking adds hint to the log as a `companion` entry
- Icon shows "available" state, changes to "viewed" after clicking
- Companion name from campaign data

---

## Step 5: Content Integration

### Goal
Implement "The Spire of the Lich King" Act 1.

#### Step 5.1: Campaign Structure
**Prerequisites:** Step 4
**File:** `src/data/campaigns/campaign-01.ts`

```typescript
export const spireOfTheLichKing: Campaign = {
  id: 'spire-of-the-lich-king',
  title: 'The Spire of the Lich King',
  description: 'Investigate the glowing ruins of the Old Watchtower...',
  companionName: 'The Elder',
  companionDescription: 'A mysterious artifact that offers cryptic guidance.',
  acts: [act1Oakhaven, act2Tower, ...]
};
```

#### Step 5.2: Act 1 - The Hook & The Approach
**Prerequisites:** Step 5.1
**File:** `src/data/campaigns/campaign-01-act1.ts`

Key scenes to implement:

**The Tavern (The Splintered Shield)**
- Opening narrative setting the scene
- Dialogue with terrified Poacher:
  - Basic questions (loop back)
  - `[Intimidate DC 10]` - reveal extra info on success
  - `[Perception DC 12]` - notice he's hiding something
- Magistrate offers bounty (sets `accepted_bounty` flag)

**The Journey**
- Short travel narrative
- Choice: investigate strange sound OR press on
- Combat trigger: Blighted Wolf (uses `startCombat` effect)

**Tower Entrance**
- Describe the sealed barrier
- Companion hint: "The stones... they hum when near the barrier."
- Puzzle choices gated by `has_singing_stone_X` flags
- Success: proceed to Act 2

#### Step 5.3: Wire Up Navigation
**Prerequisites:** Step 5.2
**File:** Updates to `App.tsx` and routing

- Add `StoryScreen` to app navigation
- Connect combat victory/defeat back to narrative
- Handle `startCombat` effect triggering `CombatScreen`
- Return to narrative after combat resolves

---

## File Structure

### New Files

```
src/
â”œâ”€â”€ types/
â”‚   â””â”€â”€ narrative.ts           # All narrative type definitions
â”œâ”€â”€ stores/
â”‚   â””â”€â”€ narrativeStore.ts      # Narrative + world state management
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ narrativeLogic.ts      # Requirements, skill checks, outcomes
â”œâ”€â”€ components/
â”‚   â””â”€â”€ narrative/
â”‚       â”œâ”€â”€ ChoiceButton.tsx   # Smart choice rendering
â”‚       â”œâ”€â”€ NarrativeLog.tsx   # Log entry display
â”‚       â”œâ”€â”€ DialogueView.tsx   # NPC conversation layout
â”‚       â””â”€â”€ CompanionHint.tsx  # Companion hint button/display
â”œâ”€â”€ screens/
â”‚   â””â”€â”€ StoryScreen.tsx        # Main narrative screen
â”œâ”€â”€ data/
â”‚   â””â”€â”€ campaigns/
â”‚       â”œâ”€â”€ test-campaign.ts   # Validation test data
â”‚       â”œâ”€â”€ campaign-01.ts     # Main campaign definition
â”‚       â””â”€â”€ campaign-01-act1.ts # Act 1 nodes
â””â”€â”€ __tests__/
    â”œâ”€â”€ utils/
    â”‚   â””â”€â”€ narrativeLogic.test.ts
    â””â”€â”€ stores/
        â””â”€â”€ narrativeStore.test.ts
```

### Modified Files

- `src/types/index.ts` - Export narrative types
- `src/App.tsx` - Add StoryScreen routing
- `src/stores/combatStore.ts` - Add callback for combat completion

---

## Testing Strategy

### Automated Unit Tests

**`narrativeLogic.test.ts`:**
- Requirement checking (all 7 requirement types)
- Skill check resolution with mocked dice
- Outcome resolution including nested checks
- Effect processing

**`narrativeStore.test.ts`:**
- Campaign loading and initialization
- Node entry with effects
- Choice selection flow
- Conversation exit preserves world state
- Available choices filtered by requirements

### Manual Verification Checklist

1. **Basic Flow:**
   - [ ] Load campaign, see first node
   - [ ] Select choice, see next node
   - [ ] Log updates with narrative and choices

2. **Skill Checks:**
   - [ ] Skill check choice shows `[Skill DC X]` prefix
   - [ ] Selecting triggers dice roll
   - [ ] Log shows roll breakdown
   - [ ] Success/failure routes to correct node

3. **Requirements:**
   - [ ] Choices with unmet requirements are hidden
   - [ ] Gaining a flag reveals previously hidden choice
   - [ ] Class-specific choices only show for correct class

4. **Conversation State:**
   - [ ] Selected choices gray out during conversation
   - [ ] Exiting and re-entering resets grayed choices
   - [ ] World flags persist after exit

5. **Companion:**
   - [ ] Hint button only shows when hint available
   - [ ] Clicking adds hint to log
   - [ ] Shows companion name from campaign

6. **Combat Integration:**
   - [ ] `startCombat` effect launches combat screen
   - [ ] Victory returns to narrative at correct node
   - [ ] Defeat triggers appropriate narrative (or permadeath)

---

## Dependencies

### From Phase 1 (Required)
- `src/types/skill.ts` - `SkillName`, `AbilityScore`
- `src/types/character.ts` - `Character`, `CharacterClass`
- `src/utils/skills.ts` - `calculateSkillBonus`
- `src/utils/dice.ts` - `rollD20`
- `src/stores/characterStore.ts` - Current player character

### New Dependencies
- None required (uses existing Zustand, React)

---

## Design Decisions

1. **Permadeath handling:** Show a narrative death scene before game over. Each act should define a `deathNodeId` that displays appropriate narrative when the player dies.

2. **Save/Load:** Wait for a dedicated save system in a later phase. World state will be kept in memory only during Phase 2.

3. **Combat return point:** Advance to a post-combat node. Combat-triggering effects should specify both `enemyId` and `onVictoryNodeId` to define where the story continues after winning.

---

## Success Criteria

Phase 2 is complete when:
- [ ] Player can progress through Act 1 narrative (Campaign 01 content needed)
- [x] Skill checks work with proper bonuses and logging âœ…
- [x] Companion hints are accessible âœ…
- [x] Combat triggers from narrative âœ… (return flow needs GameOverScreen/VictoryScreen)
- [x] All unit tests pass âœ… (36/36 passing)
- [x] World state persists across conversations âœ…

**Current Progress: 5/6 criteria met** (83%)

**To Complete Phase 2:**
1. Create Campaign 01 Act 1 content
2. Implement GameOverScreen and VictoryScreen
3. Wire combat victory â†’ story continuation flow
