# Phase 3: Rest & Resource Management - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Date:** 2025-12-31
**Status:** Not Started
**Scope:** Implement rest mechanics, camp system, merchant functionality, and safe haven features.

---

## Overview

This phase builds the downtime gameplay loop between story and combat. We implement a rest system with short/long rests, camp events, basic merchant functionality, and safe haven zones.

**Key Design Principles:**
1. **Generous rest system** - Solo-friendly balance, frequent recovery opportunities
2. **No resource scarcity** - No food/water tracking, focus on story and combat
3. **Merchant as minor feature** - Basic buy/sell, not a core gameplay loop
4. **Camp events enhance narrative** - Random encounters and story moments during rest
5. **Safe havens as story hubs** - Towns provide guaranteed safety and progression points

**Goal:** Complete gameplay loop (explore ‚Üí combat ‚Üí rest ‚Üí repeat) with 50% HP/Mana short rests and 100% recovery long rests.

**Architecture:** Rest system integrated with narrative nodes, camp event system using random encounter tables, merchant as simple item exchange with gold currency.

**Tech Stack:** Existing Zustand stores, narrative system from Phase 2, combat system from Phase 1.

---

## Progress Summary

### ‚úÖ Completed Steps

None yet - Phase 3 not started.

### üìã Remaining Work

**Step 1: Core Rest System** ‚ùå 0% COMPLETE
- ‚ùå Rest type definitions (short/long/safe haven)
- ‚ùå Resource recovery calculations
- ‚ùå Rest state tracking
- ‚ùå Rest availability logic

**Step 2: Camp Events System** ‚ùå 0% COMPLETE
- ‚ùå Camp event definitions
- ‚ùå Random encounter tables
- ‚ùå Event resolution logic
- ‚ùå Story moment integration

**Step 3: Merchant Integration** ‚ùå 0% COMPLETE
- ‚úÖ Currency system (gold) - EXISTS
- ‚úÖ Buy/sell transactions - EXISTS (src/utils/merchant.ts)
- ‚úÖ MerchantScreen UI - EXISTS
- ‚ùå Merchant inventory data definitions
- ‚ùå Safe haven ‚Üí merchant access flow

**Step 4: Safe Haven System** ‚ùå 0% COMPLETE
- ‚ùå Safe haven locations
- ‚ùå Sanctuary room definitions
- ‚ùå Guaranteed safety mechanics
- ‚ùå Town services integration

**Step 5: UI Implementation** ‚ùå 0% COMPLETE
- ‚ùå RestScreen (main rest interface)
- ‚ùå CampEventModal (random encounters)
- ‚úÖ MerchantScreen (buy/sell interface) - EXISTS
- ‚ùå RestButton component (trigger rest from story)
- ‚ùå Safe haven services UI (merchant access button)

**Step 6: Content Integration** ‚ùå 0% COMPLETE
- ‚ùå Campaign 01 camp events
- ‚ùå Merchant inventories
- ‚ùå Safe haven locations
- ‚ùå Sanctuary room placements

### üéØ Current Status

**What Works:**
- Nothing yet - awaiting Phase 3 start

**What's Missing:**
- All Phase 3 features

---

## Screen Architecture

### Phase 3 Screens

| Screen | Status | Purpose |
|--------|--------|---------|
| **RestScreen** | Phase 3 | Choose rest type, view recovery, trigger camp events |
| **MerchantScreen** | ‚úÖ EXISTS | Buy/sell items, view gold balance (already implemented) |
| **CampEventModal** | Phase 3 | Display random camp events, resolve outcomes |

### Screen Flow

```
StoryScreen
    ‚îÇ
    ‚îú‚îÄ‚ñ∫ Rest Choice ‚îÄ‚îÄ‚ñ∫ RestScreen ‚îÄ‚îÄ‚î¨‚îÄ‚ñ∫ Short Rest ‚îÄ‚îÄ‚ñ∫ Recover 50% HP/Mana ‚îÄ‚îÄ‚ñ∫ Return to Story
    ‚îÇ                                 ‚îÇ
    ‚îÇ                                 ‚îú‚îÄ‚ñ∫ Long Rest ‚îÄ‚îÄ‚ñ∫ CampEventModal ‚îÄ‚îÄ‚ñ∫ Recover 100% ‚îÄ‚îÄ‚ñ∫ Return to Story
    ‚îÇ                                 ‚îÇ
    ‚îÇ                                 ‚îî‚îÄ‚ñ∫ Visit Town ‚îÄ‚îÄ‚ñ∫ MerchantScreen ‚îÄ‚îÄ‚ñ∫ Full Recovery ‚îÄ‚îÄ‚ñ∫ Return to Story
    ‚îÇ
    ‚îî‚îÄ‚ñ∫ Continue Story
```

### Navigation State Updates

```typescript
// Add to src/types/navigation.ts
export type Screen =
  | { type: 'rest'; restType?: 'short' | 'long' | 'town' }
  | { type: 'merchant'; locationId: string }
  | { type: 'campEvent'; eventId: string; onResolveNodeId: string }
  | ... // existing screens
```

---

## Step 1: Core Rest System

### Goal
Define rest mechanics with short/long rest types and resource recovery calculations.

### Implementation Order

#### Step 1.1: Rest Type Definitions
**Prerequisites:** None
**File:** `src/types/rest.ts`

Define the three rest types and recovery rules:

```typescript
export type RestType = 'short' | 'long' | 'safe_haven';

export interface RestRecovery {
  hpPercent: number;        // 0-100, percentage of max HP to restore
  manaPercent: number;      // 0-100, percentage of max mana to restore
  restoreLimitedAbilities: boolean;  // Restore daily/encounter abilities
  guaranteed: boolean;      // If false, random encounter possible
}

export const REST_RECOVERY: Record<RestType, RestRecovery> = {
  short: {
    hpPercent: 50,
    manaPercent: 50,
    restoreLimitedAbilities: false,
    guaranteed: true,  // Short rests never interrupted
  },
  long: {
    hpPercent: 100,
    manaPercent: 100,
    restoreLimitedAbilities: true,
    guaranteed: false,  // Camp events possible
  },
  safe_haven: {
    hpPercent: 100,
    manaPercent: 100,
    restoreLimitedAbilities: true,
    guaranteed: true,  // Towns always safe
  },
};

export interface RestState {
  canRest: boolean;              // Can player rest right now?
  lastRestLocation: string;      // Node ID where player last rested
  restsThisLocation: number;     // Prevent rest spam in one location
  maxRestsPerLocation: number;   // Limit (0 = unlimited)
}
```

**Test:** `src/__tests__/types/rest.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { REST_RECOVERY } from '../../types/rest';

describe('Rest Recovery Constants', () => {
  it('should have short rest restore 50% HP and mana', () => {
    expect(REST_RECOVERY.short.hpPercent).toBe(50);
    expect(REST_RECOVERY.short.manaPercent).toBe(50);
    expect(REST_RECOVERY.short.restoreLimitedAbilities).toBe(false);
  });

  it('should have long rest restore 100% HP and mana', () => {
    expect(REST_RECOVERY.long.hpPercent).toBe(100);
    expect(REST_RECOVERY.long.manaPercent).toBe(100);
    expect(REST_RECOVERY.long.restoreLimitedAbilities).toBe(true);
  });

  it('should have safe haven guarantee safety', () => {
    expect(REST_RECOVERY.safe_haven.guaranteed).toBe(true);
  });

  it('should allow camp events during long rest', () => {
    expect(REST_RECOVERY.long.guaranteed).toBe(false);
  });
});
```

**Commands:**
```bash
# Step 1: Write the test
# (Create test file as shown above)

# Step 2: Run test to verify it passes (constants don't need failing test first)
npm test src/__tests__/types/rest.test.ts

# Step 3: Commit
git add src/types/rest.ts src/__tests__/types/rest.test.ts
git commit -m "feat(rest): add rest type definitions and recovery constants"
```

#### Step 1.2: Recovery Calculation Utilities
**Prerequisites:** Step 1.1
**File:** `src/utils/restLogic.ts`

Implement pure functions for calculating resource recovery:

```typescript
import type { Character } from '../types/character';
import type { RestType, RestRecovery } from '../types/rest';
import { REST_RECOVERY } from '../types/rest';

export interface RecoveryResult {
  hpRestored: number;
  manaRestored: number;
  newHp: number;
  newMana: number;
  abilitiesRestored: boolean;
}

/**
 * Calculate resource recovery from a rest.
 * Pure function - returns new values without mutation.
 */
export function calculateRecovery(
  character: Character,
  restType: RestType
): RecoveryResult {
  const recovery: RestRecovery = REST_RECOVERY[restType];

  const maxHp = character.maxHp;
  const maxMana = character.maxMana || 0;
  const currentHp = character.hp;
  const currentMana = character.mana || 0;

  // Calculate HP recovery
  const hpToRestore = Math.floor(maxHp * (recovery.hpPercent / 100));
  const newHp = Math.min(currentHp + hpToRestore, maxHp);
  const hpRestored = newHp - currentHp;

  // Calculate Mana recovery
  const manaToRestore = Math.floor(maxMana * (recovery.manaPercent / 100));
  const newMana = Math.min(currentMana + manaToRestore, maxMana);
  const manaRestored = newMana - currentMana;

  return {
    hpRestored,
    manaRestored,
    newHp,
    newMana,
    abilitiesRestored: recovery.restoreLimitedAbilities,
  };
}

/**
 * Apply recovery result to character.
 * Returns new character object (immutable).
 */
export function applyRecovery(
  character: Character,
  recovery: RecoveryResult
): Character {
  return {
    ...character,
    hp: recovery.newHp,
    mana: recovery.newMana,
    // TODO: Restore limited-use abilities when ability system exists
  };
}
```

**Test:** `src/__tests__/utils/restLogic.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { calculateRecovery, applyRecovery } from '../../utils/restLogic';
import type { Character } from '../../types/character';

describe('calculateRecovery', () => {
  const mockCharacter: Character = {
    id: 'test',
    name: 'Test Character',
    class: 'fighter',
    level: 3,
    hp: 10,
    maxHp: 30,
    mana: 4,
    maxMana: 12,
    // ... other required fields
  } as Character;

  it('should restore 50% HP and mana on short rest', () => {
    const result = calculateRecovery(mockCharacter, 'short');

    expect(result.hpRestored).toBe(15); // 50% of 30
    expect(result.newHp).toBe(25); // 10 + 15
    expect(result.manaRestored).toBe(6); // 50% of 12
    expect(result.newMana).toBe(10); // 4 + 6
    expect(result.abilitiesRestored).toBe(false);
  });

  it('should restore 100% HP and mana on long rest', () => {
    const result = calculateRecovery(mockCharacter, 'long');

    expect(result.hpRestored).toBe(20); // 100% of 30, but only 20 missing
    expect(result.newHp).toBe(30); // Full HP
    expect(result.manaRestored).toBe(8); // 100% of 12, but only 8 missing
    expect(result.newMana).toBe(12); // Full mana
    expect(result.abilitiesRestored).toBe(true);
  });

  it('should not exceed max HP or mana', () => {
    const fullHealthChar = { ...mockCharacter, hp: 30, mana: 12 };
    const result = calculateRecovery(fullHealthChar, 'long');

    expect(result.newHp).toBe(30);
    expect(result.newMana).toBe(12);
    expect(result.hpRestored).toBe(0);
    expect(result.manaRestored).toBe(0);
  });

  it('should handle characters with 0 max mana', () => {
    const noManaChar = { ...mockCharacter, mana: 0, maxMana: 0 };
    const result = calculateRecovery(noManaChar, 'short');

    expect(result.manaRestored).toBe(0);
    expect(result.newMana).toBe(0);
  });
});

describe('applyRecovery', () => {
  it('should return new character object with updated HP and mana', () => {
    const original: Character = {
      id: 'test',
      name: 'Test',
      hp: 10,
      mana: 4,
      // ... other fields
    } as Character;

    const recovery = {
      hpRestored: 15,
      manaRestored: 6,
      newHp: 25,
      newMana: 10,
      abilitiesRestored: false,
    };

    const updated = applyRecovery(original, recovery);

    expect(updated.hp).toBe(25);
    expect(updated.mana).toBe(10);
    expect(updated).not.toBe(original); // New object
    expect(updated.name).toBe(original.name); // Other fields preserved
  });
});
```

**Commands:**
```bash
# Step 1: Write the failing test
# (Create test file as shown above)

# Step 2: Run test to verify it fails
npm test src/__tests__/utils/restLogic.test.ts
# Expected: FAIL with "module not found"

# Step 3: Write minimal implementation
# (Create restLogic.ts as shown above)

# Step 4: Run test to verify it passes
npm test src/__tests__/utils/restLogic.test.ts
# Expected: PASS

# Step 5: Commit
git add src/utils/restLogic.ts src/__tests__/utils/restLogic.test.ts
git commit -m "feat(rest): add recovery calculation utilities"
```

#### Step 1.3: Rest Store Integration
**Prerequisites:** Step 1.2, Phase 2 narrative store
**File:** `src/stores/restStore.ts`

Create Zustand store managing rest state:

```typescript
import { create } from 'zustand';
import type { RestType, RestState } from '../types/rest';
import type { RecoveryResult } from '../utils/restLogic';
import { calculateRecovery } from '../utils/restLogic';
import { useCharacterStore } from './characterStore';
import { useNarrativeStore } from './narrativeStore';

interface RestStore extends RestState {
  // Actions
  initiateRest: (restType: RestType) => RecoveryResult | null;
  completeRest: (recovery: RecoveryResult) => void;
  canRestAtLocation: (nodeId: string) => boolean;
  resetRestTracking: () => void;
}

export const useRestStore = create<RestStore>((set, get) => ({
  // Initial state
  canRest: true,
  lastRestLocation: '',
  restsThisLocation: 0,
  maxRestsPerLocation: 0, // 0 = unlimited for now

  // Initiate rest - calculate recovery but don't apply yet
  initiateRest: (restType: RestType) => {
    const character = useCharacterStore.getState().character;
    if (!character) return null;

    const currentNode = useNarrativeStore.getState().world?.currentNodeId || '';

    // Update rest tracking
    const state = get();
    const isNewLocation = state.lastRestLocation !== currentNode;

    set({
      lastRestLocation: currentNode,
      restsThisLocation: isNewLocation ? 1 : state.restsThisLocation + 1,
    });

    return calculateRecovery(character, restType);
  },

  // Complete rest - apply recovery to character
  completeRest: (recovery: RecoveryResult) => {
    const characterStore = useCharacterStore.getState();
    const character = characterStore.character;
    if (!character) return;

    // Apply recovery
    characterStore.updateCharacter({
      hp: recovery.newHp,
      mana: recovery.newMana,
    });
  },

  // Check if rest is allowed at this location
  canRestAtLocation: (nodeId: string) => {
    const state = get();
    if (state.maxRestsPerLocation === 0) return true; // Unlimited

    const isNewLocation = state.lastRestLocation !== nodeId;
    if (isNewLocation) return true;

    return state.restsThisLocation < state.maxRestsPerLocation;
  },

  // Reset tracking (e.g., when starting new campaign)
  resetRestTracking: () => {
    set({
      canRest: true,
      lastRestLocation: '',
      restsThisLocation: 0,
    });
  },
}));
```

**Test:** `src/__tests__/stores/restStore.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useRestStore } from '../../stores/restStore';
import { useCharacterStore } from '../../stores/characterStore';
import type { Character } from '../../types/character';

// Mock character store
vi.mock('../../stores/characterStore', () => ({
  useCharacterStore: {
    getState: vi.fn(),
  },
}));

// Mock narrative store
vi.mock('../../stores/narrativeStore', () => ({
  useNarrativeStore: {
    getState: vi.fn(() => ({
      world: { currentNodeId: 'test-node' },
    })),
  },
}));

describe('RestStore', () => {
  const mockCharacter: Character = {
    id: 'test',
    name: 'Test',
    hp: 10,
    maxHp: 30,
    mana: 4,
    maxMana: 12,
  } as Character;

  beforeEach(() => {
    // Reset store
    useRestStore.getState().resetRestTracking();

    // Mock character store
    vi.mocked(useCharacterStore.getState).mockReturnValue({
      character: mockCharacter,
      updateCharacter: vi.fn(),
    } as any);
  });

  it('should calculate recovery on initiateRest', () => {
    const recovery = useRestStore.getState().initiateRest('short');

    expect(recovery).toBeDefined();
    expect(recovery?.hpRestored).toBe(15);
    expect(recovery?.newHp).toBe(25);
  });

  it('should track rest location', () => {
    const state = useRestStore.getState();

    state.initiateRest('short');

    expect(state.lastRestLocation).toBe('test-node');
    expect(state.restsThisLocation).toBe(1);
  });

  it('should increment rest count at same location', () => {
    const state = useRestStore.getState();

    state.initiateRest('short');
    state.initiateRest('short');

    expect(state.restsThisLocation).toBe(2);
  });

  it('should allow unlimited rests by default', () => {
    const state = useRestStore.getState();

    expect(state.canRestAtLocation('any-node')).toBe(true);
  });

  it('should update character HP and mana on completeRest', () => {
    const recovery = {
      hpRestored: 15,
      manaRestored: 6,
      newHp: 25,
      newMana: 10,
      abilitiesRestored: false,
    };

    useRestStore.getState().completeRest(recovery);

    expect(useCharacterStore.getState().updateCharacter).toHaveBeenCalledWith({
      hp: 25,
      mana: 10,
    });
  });
});
```

**Commands:**
```bash
# Step 1: Write the failing test
# (Create test file as shown above)

# Step 2: Run test to verify it fails
npm test src/__tests__/stores/restStore.test.ts
# Expected: FAIL

# Step 3: Write minimal implementation
# (Create restStore.ts as shown above)

# Step 4: Run test to verify it passes
npm test src/__tests__/stores/restStore.test.ts
# Expected: PASS

# Step 5: Commit
git add src/stores/restStore.ts src/__tests__/stores/restStore.test.ts
git commit -m "feat(rest): add rest store with recovery tracking"
```

---

## Step 2: Camp Events System

### Goal
Implement random camp events during long rests with narrative outcomes.

### Implementation Order

#### Step 2.1: Camp Event Type Definitions
**Prerequisites:** Step 1, Phase 2 narrative types
**File:** `src/types/campEvents.ts`

```typescript
import type { Requirement, NodeEffect } from './narrative';

export type CampEventType = 'encounter' | 'story' | 'ambush' | 'discovery';

export interface CampEvent {
  id: string;
  type: CampEventType;
  title: string;
  description: string;

  // Requirements to trigger this event
  requirements?: Requirement[];

  // Weight for random selection (higher = more likely)
  weight: number;

  // Choices available during this event
  choices: CampEventChoice[];

  // Can this event repeat?
  repeatable: boolean;
}

export interface CampEventChoice {
  id: string;
  text: string;

  // Requirements to see this choice
  requirements?: Requirement[];

  // Outcome when selected
  outcome: CampEventOutcome;
}

export type CampEventOutcome =
  | { type: 'continue' }  // Continue resting
  | { type: 'interrupt'; effect: NodeEffect[] }  // Cancel rest, apply effects
  | { type: 'combat'; enemyId: string; onVictoryReturn: 'rest' | 'story' };

export interface CampEventTable {
  locationId: string;      // Which location/act uses this table
  events: CampEvent[];
  rollChance: number;      // 0-100, chance of event happening at all
}
```

**Test:** `src/__tests__/types/campEvents.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import type { CampEvent, CampEventTable } from '../../types/campEvents';

describe('Camp Event Types', () => {
  it('should create valid camp event', () => {
    const event: CampEvent = {
      id: 'night-prowler',
      type: 'encounter',
      title: 'Night Prowler',
      description: 'You hear something moving in the darkness...',
      weight: 10,
      repeatable: true,
      choices: [
        {
          id: 'investigate',
          text: 'Investigate the sound',
          outcome: { type: 'continue' },
        },
      ],
    };

    expect(event.id).toBe('night-prowler');
    expect(event.choices).toHaveLength(1);
  });

  it('should create valid camp event table', () => {
    const table: CampEventTable = {
      locationId: 'act1-forest',
      rollChance: 50,
      events: [],
    };

    expect(table.rollChance).toBe(50);
    expect(table.events).toEqual([]);
  });
});
```

**Commands:**
```bash
# Step 1: Write test
# (Create test file)

# Step 2: Run test
npm test src/__tests__/types/campEvents.test.ts
# Expected: PASS (type validation)

# Step 3: Commit
git add src/types/campEvents.ts src/__tests__/types/campEvents.test.ts
git commit -m "feat(camp): add camp event type definitions"
```

#### Step 2.2: Camp Event Resolution Logic
**Prerequisites:** Step 2.1
**File:** `src/utils/campEventLogic.ts`

```typescript
import type { CampEvent, CampEventTable, CampEventOutcome } from '../types/campEvents';
import type { Character } from '../types/character';
import type { WorldState } from '../types/narrative';
import { checkAllRequirements } from './narrativeLogic';

/**
 * Determine if a camp event should occur.
 * Uses weighted random selection from available events.
 */
export function rollForCampEvent(
  table: CampEventTable,
  world: WorldState,
  character: Character
): CampEvent | null {
  // First, check if any event happens at all
  const eventRoll = Math.random() * 100;
  if (eventRoll > table.rollChance) {
    return null; // No event
  }

  // Filter events by requirements
  const availableEvents = table.events.filter(event => {
    if (!event.requirements) return true;
    return checkAllRequirements(event.requirements, world, character);
  });

  if (availableEvents.length === 0) return null;

  // Weighted random selection
  const totalWeight = availableEvents.reduce((sum, e) => sum + e.weight, 0);
  let roll = Math.random() * totalWeight;

  for (const event of availableEvents) {
    roll -= event.weight;
    if (roll <= 0) {
      return event;
    }
  }

  return availableEvents[0]; // Fallback
}

/**
 * Get available choices for a camp event based on requirements.
 */
export function getAvailableCampChoices(
  event: CampEvent,
  world: WorldState,
  character: Character
) {
  return event.choices.filter(choice => {
    if (!choice.requirements) return true;
    return checkAllRequirements(choice.requirements, world, character);
  });
}

/**
 * Resolve a camp event outcome.
 */
export function resolveCampOutcome(
  outcome: CampEventOutcome
): {
  continueRest: boolean;
  combatTriggered: boolean;
  effects: any[];
} {
  switch (outcome.type) {
    case 'continue':
      return { continueRest: true, combatTriggered: false, effects: [] };

    case 'interrupt':
      return { continueRest: false, combatTriggered: false, effects: outcome.effect };

    case 'combat':
      return { continueRest: false, combatTriggered: true, effects: [] };
  }
}
```

**Test:** `src/__tests__/utils/campEventLogic.test.ts`

```typescript
import { describe, it, expect, vi } from 'vitest';
import { rollForCampEvent, getAvailableCampChoices, resolveCampOutcome } from '../../utils/campEventLogic';
import type { CampEvent, CampEventTable } from '../../types/campEvents';

describe('rollForCampEvent', () => {
  const mockTable: CampEventTable = {
    locationId: 'test',
    rollChance: 100, // Always trigger for testing
    events: [
      {
        id: 'event1',
        type: 'story',
        title: 'Event 1',
        description: 'Test',
        weight: 10,
        repeatable: true,
        choices: [],
      },
      {
        id: 'event2',
        type: 'encounter',
        title: 'Event 2',
        description: 'Test',
        weight: 5,
        repeatable: true,
        choices: [],
      },
    ],
  };

  it('should return null if roll chance fails', () => {
    const table = { ...mockTable, rollChance: 0 };
    const result = rollForCampEvent(table, {} as any, {} as any);

    expect(result).toBeNull();
  });

  it('should select event based on weight', () => {
    // Mock Math.random to return specific values
    const originalRandom = Math.random;

    // First call (event check) = 0.5 (triggers event)
    // Second call (event selection) = 0.1 (should select event1)
    let callCount = 0;
    Math.random = vi.fn(() => {
      callCount++;
      return callCount === 1 ? 0.5 : 0.1;
    });

    const result = rollForCampEvent(mockTable, {} as any, {} as any);

    expect(result?.id).toBe('event1');

    Math.random = originalRandom;
  });
});

describe('resolveCampOutcome', () => {
  it('should allow rest to continue on continue outcome', () => {
    const result = resolveCampOutcome({ type: 'continue' });

    expect(result.continueRest).toBe(true);
    expect(result.combatTriggered).toBe(false);
  });

  it('should interrupt rest on interrupt outcome', () => {
    const result = resolveCampOutcome({
      type: 'interrupt',
      effect: [{ type: 'damage', amount: 5 }],
    });

    expect(result.continueRest).toBe(false);
    expect(result.effects).toHaveLength(1);
  });

  it('should trigger combat on combat outcome', () => {
    const result = resolveCampOutcome({
      type: 'combat',
      enemyId: 'wolf',
      onVictoryReturn: 'rest',
    });

    expect(result.combatTriggered).toBe(true);
    expect(result.continueRest).toBe(false);
  });
});
```

**Commands:**
```bash
# Step 1: Write failing test
# (Create test file)

# Step 2: Run test to verify it fails
npm test src/__tests__/utils/campEventLogic.test.ts
# Expected: FAIL

# Step 3: Implement logic
# (Create campEventLogic.ts)

# Step 4: Run test to verify it passes
npm test src/__tests__/utils/campEventLogic.test.ts
# Expected: PASS

# Step 5: Commit
git add src/utils/campEventLogic.ts src/__tests__/utils/campEventLogic.test.ts
git commit -m "feat(camp): add camp event resolution logic"
```

#### Step 2.3: Camp Event Store
**Prerequisites:** Step 2.2
**File:** `src/stores/campEventStore.ts`

```typescript
import { create } from 'zustand';
import type { CampEvent, CampEventTable } from '../types/campEvents';
import { rollForCampEvent, resolveCampOutcome } from '../utils/campEventLogic';
import { useCharacterStore } from './characterStore';
import { useNarrativeStore } from './narrativeStore';

interface CampEventStore {
  currentEvent: CampEvent | null;
  eventTables: Record<string, CampEventTable>;

  // Actions
  loadEventTable: (table: CampEventTable) => void;
  triggerCampEvent: (locationId: string) => CampEvent | null;
  selectChoice: (choiceId: string) => void;
  clearEvent: () => void;
}

export const useCampEventStore = create<CampEventStore>((set, get) => ({
  currentEvent: null,
  eventTables: {},

  loadEventTable: (table: CampEventTable) => {
    set(state => ({
      eventTables: {
        ...state.eventTables,
        [table.locationId]: table,
      },
    }));
  },

  triggerCampEvent: (locationId: string) => {
    const table = get().eventTables[locationId];
    if (!table) return null;

    const character = useCharacterStore.getState().character;
    const world = useNarrativeStore.getState().world;
    if (!character || !world) return null;

    const event = rollForCampEvent(table, world, character);
    set({ currentEvent: event });
    return event;
  },

  selectChoice: (choiceId: string) => {
    const { currentEvent } = get();
    if (!currentEvent) return;

    const choice = currentEvent.choices.find(c => c.id === choiceId);
    if (!choice) return;

    const result = resolveCampOutcome(choice.outcome);

    // TODO: Apply effects, trigger combat if needed

    if (result.continueRest) {
      set({ currentEvent: null });
    }
  },

  clearEvent: () => {
    set({ currentEvent: null });
  },
}));
```

**Test:** `src/__tests__/stores/campEventStore.test.ts`

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { useCampEventStore } from '../../stores/campEventStore';
import type { CampEventTable } from '../../types/campEvents';

describe('CampEventStore', () => {
  beforeEach(() => {
    useCampEventStore.getState().clearEvent();
  });

  it('should load event table', () => {
    const table: CampEventTable = {
      locationId: 'test-location',
      rollChance: 50,
      events: [],
    };

    useCampEventStore.getState().loadEventTable(table);

    expect(useCampEventStore.getState().eventTables['test-location']).toBeDefined();
  });

  it('should clear current event', () => {
    useCampEventStore.setState({
      currentEvent: {
        id: 'test',
        type: 'story',
        title: 'Test',
        description: 'Test',
        weight: 10,
        repeatable: true,
        choices: [],
      },
    });

    useCampEventStore.getState().clearEvent();

    expect(useCampEventStore.getState().currentEvent).toBeNull();
  });
});
```

**Commands:**
```bash
# Step 1: Write test
# Step 2: Run test (should fail)
npm test src/__tests__/stores/campEventStore.test.ts

# Step 3: Implement store
# Step 4: Run test (should pass)
npm test src/__tests__/stores/campEventStore.test.ts

# Step 5: Commit
git add src/stores/campEventStore.ts src/__tests__/stores/campEventStore.test.ts
git commit -m "feat(camp): add camp event store"
```

---

## Step 3: Merchant Integration

### Goal
Connect existing merchant system to safe havens and narrative flow.

**Note:** The merchant system already exists (`src/screens/MerchantScreen.tsx`, `src/utils/merchant.ts`). This step focuses on integration with the rest/safe haven system.

### Implementation Order

#### Step 3.1: Merchant Inventory Data Structure
**Prerequisites:** Step 1
**File:** `src/types/merchantInventory.ts`

Define data structure for merchant shop inventories (existing MerchantScreen expects `shopInventory` and `buyPrices` props):

```typescript
export interface MerchantInventory {
  merchantId: string;
  locationId: string;        // Which safe haven location has this merchant
  shopInventory: string[];   // Item IDs available for purchase
  buyPrices: Record<string, number>;  // Item ID -> gold price
}
```

**Test:** `src/__tests__/types/merchantInventory.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import type { MerchantInventory } from '../../types/merchantInventory';

describe('Merchant Inventory Types', () => {
  it('should create valid merchant inventory', () => {
    const inventory: MerchantInventory = {
      merchantId: 'oakhaven-general',
      locationId: 'act1-oakhaven',
      shopInventory: ['health-potion', 'mana-potion'],
      buyPrices: {
        'health-potion': 50,
        'mana-potion': 50,
      },
    };

    expect(inventory.shopInventory).toHaveLength(2);
    expect(inventory.buyPrices['health-potion']).toBe(50);
  });
});
```

**Commands:**
```bash
git add src/types/merchantInventory.ts src/__tests__/types/merchantInventory.test.ts
git commit -m "feat(merchant): add merchant inventory data types"
```

#### Step 3.2: Safe Haven ‚Üí Merchant Navigation
**Prerequisites:** Step 4.2 (SafeHavenStore)
**File:** Update `src/types/safeHaven.ts`

Add merchant reference to safe haven definition:

```typescript
export interface SafeHaven {
  id: string;
  type: SafeHavenType;
  name: string;
  locationId: string;

  // Services available
  merchantId?: string;         // Reference to merchant inventory
  merchantAvailable: boolean;  // Can access merchant here
  questGiverPresent: boolean;
  levelUpAllowed: boolean;

  // Flavor
  description?: string;
  atmosphere?: string;
}
```

**No test needed** - Type definition only.

**Commands:**
```bash
git add src/types/safeHaven.ts
git commit -m "feat(merchant): link merchants to safe havens"
```

---

## Step 4: Safe Haven System

### Goal
Define safe rest locations (towns, sanctuary rooms) with guaranteed recovery.

### Implementation Order

#### Step 4.1: Safe Haven Types
**Prerequisites:** Step 1
**File:** `src/types/safeHaven.ts`

```typescript
export type SafeHavenType = 'town' | 'sanctuary' | 'inn';

export interface SafeHaven {
  id: string;
  type: SafeHavenType;
  name: string;
  locationId: string;      // Which story node represents this haven

  // Services available
  merchantAvailable: boolean;
  questGiverPresent: boolean;
  levelUpAllowed: boolean;

  // Flavor
  description?: string;
  atmostphere?: string;
}

// Sanctuary rooms in dungeons
export interface SanctuaryRoom extends SafeHaven {
  type: 'sanctuary';
  oneTimeUse: boolean;     // Can only rest here once
}
```

**Test:** `src/__tests__/types/safeHaven.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import type { SafeHaven, SanctuaryRoom } from '../../types/safeHaven';

describe('Safe Haven Types', () => {
  it('should create valid town safe haven', () => {
    const town: SafeHaven = {
      id: 'oakhaven',
      type: 'town',
      name: 'Oakhaven',
      locationId: 'act1-town',
      merchantAvailable: true,
      questGiverPresent: true,
      levelUpAllowed: true,
    };

    expect(town.type).toBe('town');
    expect(town.merchantAvailable).toBe(true);
  });

  it('should create valid sanctuary room', () => {
    const sanctuary: SanctuaryRoom = {
      id: 'tower-sanctuary',
      type: 'sanctuary',
      name: 'Ancient Prayer Room',
      locationId: 'tower-level-2',
      merchantAvailable: false,
      questGiverPresent: false,
      levelUpAllowed: false,
      oneTimeUse: true,
    };

    expect(sanctuary.oneTimeUse).toBe(true);
  });
});
```

**Commands:**
```bash
git add src/types/safeHaven.ts src/__tests__/types/safeHaven.test.ts
git commit -m "feat(rest): add safe haven type definitions"
```

#### Step 4.2: Safe Haven Store
**Prerequisites:** Step 4.1
**File:** `src/stores/safeHavenStore.ts`

```typescript
import { create } from 'zustand';
import type { SafeHaven } from '../types/safeHaven';

interface SafeHavenStore {
  safeHavens: Record<string, SafeHaven>;
  visitedSanctuaries: Set<string>;  // Track one-time use sanctuaries

  // Actions
  registerSafeHaven: (haven: SafeHaven) => void;
  isSafeHaven: (locationId: string) => boolean;
  getSafeHaven: (locationId: string) => SafeHaven | null;
  canUseHaven: (havenId: string) => boolean;
  markSanctuaryUsed: (sanctuaryId: string) => void;
}

export const useSafeHavenStore = create<SafeHavenStore>((set, get) => ({
  safeHavens: {},
  visitedSanctuaries: new Set(),

  registerSafeHaven: (haven: SafeHaven) => {
    set(state => ({
      safeHavens: {
        ...state.safeHavens,
        [haven.locationId]: haven,
      },
    }));
  },

  isSafeHaven: (locationId: string) => {
    return !!get().safeHavens[locationId];
  },

  getSafeHaven: (locationId: string) => {
    return get().safeHavens[locationId] || null;
  },

  canUseHaven: (havenId: string) => {
    const haven = Object.values(get().safeHavens).find(h => h.id === havenId);
    if (!haven) return false;

    // Check if sanctuary is one-time use and already visited
    if (haven.type === 'sanctuary') {
      const sanctuary = haven as any;
      if (sanctuary.oneTimeUse && get().visitedSanctuaries.has(havenId)) {
        return false;
      }
    }

    return true;
  },

  markSanctuaryUsed: (sanctuaryId: string) => {
    set(state => ({
      visitedSanctuaries: new Set([...state.visitedSanctuaries, sanctuaryId]),
    }));
  },
}));
```

**Test:** `src/__tests__/stores/safeHavenStore.test.ts`

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { useSafeHavenStore } from '../../stores/safeHavenStore';
import type { SafeHaven } from '../../types/safeHaven';

describe('SafeHavenStore', () => {
  const mockTown: SafeHaven = {
    id: 'town1',
    type: 'town',
    name: 'Test Town',
    locationId: 'act1-town',
    merchantAvailable: true,
    questGiverPresent: true,
    levelUpAllowed: true,
  };

  beforeEach(() => {
    useSafeHavenStore.setState({
      safeHavens: {},
      visitedSanctuaries: new Set(),
    });
  });

  it('should register safe haven', () => {
    useSafeHavenStore.getState().registerSafeHaven(mockTown);

    expect(useSafeHavenStore.getState().isSafeHaven('act1-town')).toBe(true);
  });

  it('should get safe haven by location', () => {
    useSafeHavenStore.getState().registerSafeHaven(mockTown);

    const haven = useSafeHavenStore.getState().getSafeHaven('act1-town');

    expect(haven?.name).toBe('Test Town');
  });

  it('should track one-time sanctuary usage', () => {
    const sanctuary: SafeHaven = {
      id: 'sanc1',
      type: 'sanctuary',
      name: 'Sanctuary',
      locationId: 'dungeon-room',
      merchantAvailable: false,
      questGiverPresent: false,
      levelUpAllowed: false,
    };

    useSafeHavenStore.getState().registerSafeHaven(sanctuary);
    useSafeHavenStore.getState().markSanctuaryUsed('sanc1');

    expect(useSafeHavenStore.getState().visitedSanctuaries.has('sanc1')).toBe(true);
  });
});
```

**Commands:**
```bash
npm test src/__tests__/stores/safeHavenStore.test.ts
# (TDD)

git add src/stores/safeHavenStore.ts src/__tests__/stores/safeHavenStore.test.ts
git commit -m "feat(rest): add safe haven store"
```

---

## Step 5: UI Implementation

### Goal
Build UI screens for rest, camp events, and merchant interactions.

### Implementation Order

#### Step 5.1: RestScreen - Main Rest Interface
**Prerequisites:** Step 1-4
**File:** `src/screens/RestScreen.tsx`

```typescript
import React, { useState } from 'react';
import { useRestStore } from '../stores/restStore';
import { useSafeHavenStore } from '../stores/safeHavenStore';
import { useCampEventStore } from '../stores/campEventStore';
import { useCharacterStore } from '../stores/characterStore';
import { useNarrativeStore } from '../stores/narrativeStore';
import type { RestType } from '../types/rest';

export const RestScreen: React.FC = () => {
  const character = useCharacterStore(state => state.character);
  const currentNodeId = useNarrativeStore(state => state.world?.currentNodeId);
  const isSafeHaven = useSafeHavenStore(state =>
    currentNodeId ? state.isSafeHaven(currentNodeId) : false
  );

  const [showRecovery, setShowRecovery] = useState(false);
  const [recovery, setRecovery] = useState<any>(null);

  const handleRest = (restType: RestType) => {
    const result = useRestStore.getState().initiateRest(restType);

    if (!result) return;

    // Check for camp events if long rest and not safe haven
    if (restType === 'long' && !isSafeHaven) {
      const event = useCampEventStore.getState().triggerCampEvent(currentNodeId || '');

      if (event) {
        // Show camp event modal
        return;
      }
    }

    // No event, complete rest
    useRestStore.getState().completeRest(result);
    setRecovery(result);
    setShowRecovery(true);
  };

  if (!character) return <div>Loading...</div>;

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-4">
      <div className="max-w-2xl w-full bg-gray-800 rounded-lg shadow-xl p-8">
        <h1 className="text-3xl font-bold mb-6">Rest</h1>

        <div className="mb-8">
          <p className="text-gray-300 mb-2">Current HP: {character.hp} / {character.maxHp}</p>
          {character.maxMana > 0 && (
            <p className="text-gray-300">Current Mana: {character.mana} / {character.maxMana}</p>
          )}
        </div>

        {showRecovery && recovery && (
          <div className="bg-green-900 border border-green-700 rounded p-4 mb-6">
            <h2 className="text-xl font-bold mb-2">Recovery Complete</h2>
            <p>HP restored: +{recovery.hpRestored}</p>
            <p>Mana restored: +{recovery.manaRestored}</p>
          </div>
        )}

        <div className="space-y-4">
          <RestButton
            label="Short Rest"
            description="Restore 50% HP and Mana (instant, safe)"
            onClick={() => handleRest('short')}
          />

          <RestButton
            label="Long Rest"
            description="Restore 100% HP and Mana (camp events possible)"
            onClick={() => handleRest('long')}
            variant={isSafeHaven ? 'safe' : 'risky'}
          />

          {isSafeHaven && (
            <RestButton
              label="Rest at Inn"
              description="Full recovery in safety, access services"
              onClick={() => handleRest('safe_haven')}
              variant="safe"
            />
          )}
        </div>

        <button
          onClick={() => {/* Return to story */}}
          className="mt-8 w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded"
        >
          Continue Adventure
        </button>
      </div>
    </div>
  );
};

interface RestButtonProps {
  label: string;
  description: string;
  onClick: () => void;
  variant?: 'safe' | 'risky';
}

const RestButton: React.FC<RestButtonProps> = ({
  label,
  description,
  onClick,
  variant = 'safe'
}) => {
  const bgColor = variant === 'safe' ? 'bg-blue-600 hover:bg-blue-500' : 'bg-yellow-600 hover:bg-yellow-500';

  return (
    <button
      onClick={onClick}
      className={`w-full ${bgColor} text-white font-bold py-4 px-6 rounded text-left transition`}
    >
      <div className="text-xl mb-1">{label}</div>
      <div className="text-sm opacity-90">{description}</div>
    </button>
  );
};
```

**Manual Test:**
```bash
# Step 1: Create component
# Step 2: Add to App.tsx routing
# Step 3: Run dev server
npm run dev

# Step 4: Navigate to rest screen
# Expected: See rest options, HP/mana display

# Step 5: Click short rest
# Expected: See recovery message, HP/mana updated

# Step 6: Commit
git add src/screens/RestScreen.tsx
git commit -m "feat(ui): add rest screen with recovery UI"
```

#### Step 5.2: CampEventModal - Random Encounters
**Prerequisites:** Step 5.1, Step 2 (camp events)
**File:** `src/components/rest/CampEventModal.tsx`

```typescript
import React from 'react';
import { useCampEventStore } from '../../stores/campEventStore';
import { useCharacterStore } from '../../stores/characterStore';
import { useNarrativeStore } from '../../stores/narrativeStore';
import { getAvailableCampChoices } from '../../utils/campEventLogic';

interface CampEventModalProps {
  onClose: () => void;
}

export const CampEventModal: React.FC<CampEventModalProps> = ({ onClose }) => {
  const currentEvent = useCampEventStore(state => state.currentEvent);
  const character = useCharacterStore(state => state.character);
  const world = useNarrativeStore(state => state.world);

  if (!currentEvent || !character || !world) return null;

  const availableChoices = getAvailableCampChoices(currentEvent, world, character);

  const handleChoice = (choiceId: string) => {
    useCampEventStore.getState().selectChoice(choiceId);
    onClose();
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
      <div className="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full p-8">
        <h2 className="text-2xl font-bold text-yellow-400 mb-2">{currentEvent.title}</h2>
        <p className="text-gray-300 mb-6 whitespace-pre-wrap">{currentEvent.description}</p>

        <div className="space-y-3">
          {availableChoices.map(choice => (
            <button
              key={choice.id}
              onClick={() => handleChoice(choice.id)}
              className="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded text-left transition"
            >
              {choice.text}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
};
```

**Manual Test:**
```bash
# Integrate with RestScreen
# Trigger long rest in non-safe location
# Expected: Modal appears with camp event
# Select choice
# Expected: Modal closes, rest completes or combat starts

git add src/components/rest/CampEventModal.tsx
git commit -m "feat(ui): add camp event modal"
```

#### Step 5.3: Safe Haven Services UI
**Prerequisites:** Step 4
**File:** Update `src/screens/RestScreen.tsx`

Add "Visit Merchant" button when at safe haven with merchant:

```typescript
// In RestScreen.tsx, after rest options:

{isSafeHaven && safeHaven?.merchantAvailable && (
  <button
    onClick={() => {
      // Navigate to merchant screen
      // Pass shopInventory and buyPrices from merchant data
    }}
    className="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-4 px-6 rounded text-left transition"
  >
    <div className="text-xl mb-1">Visit Merchant</div>
    <div className="text-sm opacity-90">Buy and sell items</div>
  </button>
)}
```

**Manual Test:**
```bash
npm run dev

# Navigate to safe haven (town)
# Expected: See "Visit Merchant" button
# Click button
# Expected: Open existing MerchantScreen
# Buy/sell items
# Expected: Transactions work as before

git add src/screens/RestScreen.tsx
git commit -m "feat(ui): add merchant access from safe havens"
```

---

## Step 6: Content Integration

### Goal
Create Campaign 01 camp events, merchant inventories, and safe haven definitions.

### Implementation Order

#### Step 6.1: Campaign 01 Camp Events
**Prerequisites:** Step 2
**File:** `src/data/campaigns/campaign-01-camp-events.ts`

```typescript
import type { CampEventTable } from '../../types/campEvents';

export const act1ForestCampEvents: CampEventTable = {
  locationId: 'act1-forest',
  rollChance: 40, // 40% chance of event during long rest
  events: [
    {
      id: 'wolf-howl',
      type: 'encounter',
      title: 'Distant Howls',
      description: 'As you settle in for the night, you hear wolves howling in the distance. They seem to be getting closer...',
      weight: 10,
      repeatable: true,
      choices: [
        {
          id: 'investigate',
          text: 'Investigate the sounds',
          outcome: {
            type: 'combat',
            enemyId: 'blighted-wolf',
            onVictoryReturn: 'rest',
          },
        },
        {
          id: 'ignore',
          text: 'Keep watch and ignore them',
          outcome: { type: 'continue' },
        },
      ],
    },
    {
      id: 'strange-light',
      type: 'discovery',
      title: 'Strange Light',
      description: 'A faint blue glow emanates from between the trees nearby. It pulses rhythmically, almost like breathing.',
      weight: 5,
      repeatable: false,
      choices: [
        {
          id: 'approach',
          text: 'Approach the light',
          outcome: {
            type: 'interrupt',
            effect: [
              { type: 'giveItem', itemId: 'mysterious-gem' },
              { type: 'setFlag', flag: 'found_mysterious_gem', value: true },
            ],
          },
        },
        {
          id: 'avoid',
          text: 'Avoid it and rest',
          outcome: { type: 'continue' },
        },
      ],
    },
    {
      id: 'elder-whisper',
      type: 'story',
      title: 'The Elder\'s Memory',
      description: 'The Elder suddenly grows warm. "I remember this place," it whispers. "Long ago, when I was... different."',
      weight: 3,
      repeatable: false,
      choices: [
        {
          id: 'listen',
          text: 'Listen to the story',
          outcome: {
            type: 'interrupt',
            effect: [
              { type: 'setFlag', flag: 'elder_memory_1', value: true },
            ],
          },
        },
      ],
    },
  ],
};

export const act2TowerCampEvents: CampEventTable = {
  locationId: 'act2-tower',
  rollChance: 60, // Higher chance in dangerous tower
  events: [
    {
      id: 'undead-patrol',
      type: 'ambush',
      title: 'Undead Patrol',
      description: 'Skeletal guards march through the hallway. You hold your breath, hoping they don\'t notice your hiding spot.',
      weight: 15,
      repeatable: true,
      choices: [
        {
          id: 'fight',
          text: 'Ambush them first',
          outcome: {
            type: 'combat',
            enemyId: 'skeleton-warrior',
            onVictoryReturn: 'rest',
          },
        },
        {
          id: 'hide',
          text: 'Stay hidden',
          requirements: [{ type: 'skill', skill: 'stealth', minRanks: 2 }],
          outcome: { type: 'continue' },
        },
        {
          id: 'hide-fail',
          text: 'Try to hide (untrained)',
          outcome: {
            type: 'combat',
            enemyId: 'skeleton-warrior',
            onVictoryReturn: 'rest',
          },
        },
      ],
    },
  ],
};
```

**Commands:**
```bash
git add src/data/campaigns/campaign-01-camp-events.ts
git commit -m "feat(content): add Campaign 01 camp events"
```

#### Step 6.2: Merchant Inventories
**Prerequisites:** Step 3
**File:** `src/data/merchants/oakhaven-merchant.ts`

```typescript
import type { MerchantInventory } from '../../types/merchant';

export const oakhavenGeneralStore: MerchantInventory = {
  merchantId: 'oakhaven-merchant',
  locationId: 'act1-oakhaven-town',
  buybackRate: 0.5, // Sell items for 50% of base price
  items: [
    { itemId: 'health-potion', price: 50, stock: -1 }, // Unlimited stock
    { itemId: 'mana-potion', price: 50, stock: -1 },
    { itemId: 'antidote', price: 25, stock: 5 },
    { itemId: 'longsword', price: 150, stock: 2 },
    { itemId: 'leather-armor', price: 100, stock: 3 },
    {
      itemId: 'magic-amulet',
      price: 500,
      stock: 1,
      requirements: [{ type: 'flag', flag: 'defeated_lich', value: false }],
    },
  ],
};
```

**Commands:**
```bash
git add src/data/merchants/oakhaven-merchant.ts
git commit -m "feat(content): add Oakhaven merchant inventory"
```

#### Step 6.3: Safe Haven Definitions
**Prerequisites:** Step 4
**File:** `src/data/safeHavens/campaign-01-havens.ts`

```typescript
import type { SafeHaven, SanctuaryRoom } from '../../types/safeHaven';

export const oakhavenTown: SafeHaven = {
  id: 'oakhaven',
  type: 'town',
  name: 'Oakhaven',
  locationId: 'act1-oakhaven-town',
  merchantAvailable: true,
  questGiverPresent: true,
  levelUpAllowed: true,
  description: 'A peaceful village on the edge of Blackwood Forest.',
  atmostphere: 'The smell of fresh bread and the sound of hammering fill the air.',
};

export const towerSanctuary: SanctuaryRoom = {
  id: 'tower-sanctuary',
  type: 'sanctuary',
  name: 'Forgotten Prayer Room',
  locationId: 'act2-tower-sanctuary',
  merchantAvailable: false,
  questGiverPresent: false,
  levelUpAllowed: false,
  oneTimeUse: true,
  description: 'A small chamber with intact holy symbols. The undead seem to avoid this place.',
};

export const campaign01SafeHavens = [
  oakhavenTown,
  towerSanctuary,
];
```

**Commands:**
```bash
git add src/data/safeHavens/campaign-01-havens.ts
git commit -m "feat(content): add Campaign 01 safe havens"
```

---

## File Structure

### New Files

```
src/
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ rest.ts                    # Rest types and constants
‚îÇ   ‚îú‚îÄ‚îÄ campEvents.ts              # Camp event definitions
‚îÇ   ‚îú‚îÄ‚îÄ merchantInventory.ts       # Merchant inventory data structure
‚îÇ   ‚îî‚îÄ‚îÄ safeHaven.ts               # Safe haven definitions
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ restLogic.ts               # Recovery calculations
‚îÇ   ‚îú‚îÄ‚îÄ campEventLogic.ts          # Camp event resolution
‚îÇ   ‚îî‚îÄ‚îÄ merchant.ts                # ‚úÖ EXISTS - Buy/sell transactions
‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îú‚îÄ‚îÄ restStore.ts               # Rest state management
‚îÇ   ‚îú‚îÄ‚îÄ campEventStore.ts          # Camp event state
‚îÇ   ‚îî‚îÄ‚îÄ safeHavenStore.ts          # Safe haven tracking
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ RestScreen.tsx             # Main rest interface
‚îÇ   ‚îî‚îÄ‚îÄ MerchantScreen.tsx         # ‚úÖ EXISTS - Buy/sell screen
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ rest/
‚îÇ       ‚îî‚îÄ‚îÄ CampEventModal.tsx     # Camp event popup
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ campaigns/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ campaign-01-camp-events.ts
‚îÇ   ‚îú‚îÄ‚îÄ merchants/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ oakhaven-merchant.ts
‚îÇ   ‚îî‚îÄ‚îÄ safeHavens/
‚îÇ       ‚îî‚îÄ‚îÄ campaign-01-havens.ts
‚îî‚îÄ‚îÄ __tests__/
    ‚îú‚îÄ‚îÄ types/
    ‚îÇ   ‚îú‚îÄ‚îÄ rest.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ campEvents.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ merchantInventory.test.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ safeHaven.test.ts
    ‚îú‚îÄ‚îÄ utils/
    ‚îÇ   ‚îú‚îÄ‚îÄ restLogic.test.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ campEventLogic.test.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ merchant.test.ts       # ‚úÖ EXISTS
    ‚îî‚îÄ‚îÄ stores/
        ‚îú‚îÄ‚îÄ restStore.test.ts
        ‚îú‚îÄ‚îÄ campEventStore.test.ts
        ‚îî‚îÄ‚îÄ safeHavenStore.test.ts
```

### Modified Files

- `src/types/index.ts` - Export new types
- `src/types/character.ts` - ‚úÖ Already has `gold`, `inventory`, `maxInventorySlots` fields
- `src/types/navigation.ts` - Add rest/merchant screen types
- `src/App.tsx` - Add RestScreen routing (MerchantScreen already integrated)
- `src/screens/StoryScreen.tsx` - Add "Rest" button to trigger RestScreen

---

## Testing Strategy

### Automated Unit Tests

**Core Logic Tests (High Priority):**
1. `restLogic.test.ts` - Recovery calculations, edge cases (0 HP, full HP, no mana)
2. `merchantLogic.test.ts` - Buy/sell transactions, insufficient gold, stock limits
3. `campEventLogic.test.ts` - Weighted selection, requirement filtering

**Store Tests (Medium Priority):**
1. `restStore.test.ts` - Rest tracking, location limits
2. `merchantStore.test.ts` - Buy/sell integration with character
3. `campEventStore.test.ts` - Event triggering

**Type Tests (Low Priority):**
- Validate constant definitions compile correctly

### Manual Verification Checklist

1. **Short Rest:**
   - [ ] Restores exactly 50% HP and mana
   - [ ] Instant (no camp events)
   - [ ] Can be used anywhere
   - [ ] Cannot exceed max HP/mana

2. **Long Rest:**
   - [ ] Restores 100% HP and mana
   - [ ] Triggers camp event (40-60% chance)
   - [ ] Can be interrupted by combat
   - [ ] Completes if no event occurs

3. **Safe Haven:**
   - [ ] Always guaranteed safety
   - [ ] Full recovery
   - [ ] Access to merchant if available
   - [ ] Sanctuary rooms usable once only

4. **Camp Events:**
   - [ ] Random selection based on weight
   - [ ] Requirements filter choices correctly
   - [ ] Combat interrupts rest
   - [ ] "Continue" outcome completes rest

5. **Merchant:**
   - [ ] Cannot buy without enough gold
   - [ ] Stock decreases on purchase
   - [ ] Sell price is 50% of base
   - [ ] Unlimited stock items don't run out

6. **Integration:**
   - [ ] Rest from story screen
   - [ ] Return to story after rest
   - [ ] Combat victory returns to rest/story
   - [ ] Character state persists

---

## Dependencies

### From Phase 1 (Required)
- `src/types/character.ts` - ‚úÖ `Character` type (already has `gold`, `inventory`, `maxInventorySlots`)
- `src/stores/characterStore.ts` - `updateCharacter` action
- `src/utils/dice.ts` - Random number generation
- `src/utils/merchant.ts` - ‚úÖ EXISTS - Buy/sell transaction logic
- `src/screens/MerchantScreen.tsx` - ‚úÖ EXISTS - Merchant UI

### From Phase 2 (Required)
- `src/types/narrative.ts` - `Requirement`, `NodeEffect`, `WorldState`
- `src/utils/narrativeLogic.ts` - `checkAllRequirements`, `processNodeEffects`
- `src/stores/narrativeStore.ts` - World state access

### New Dependencies
- None (uses existing Zustand, React)

---

## Design Decisions

1. **No resource scarcity initially:** Generous rest system for solo-friendly balance. No food/water tracking, unlimited short rests. May add rest limits per location in future.

2. **Merchant as minor feature:** ‚úÖ Already implemented (`src/screens/MerchantScreen.tsx`). Phase 3 integrates it with safe havens. No haggling, reputation, or complex inventory management. Focus on story and combat.

3. **Camp events enhance narrative:** Random encounters during long rests add tension and world-building. Events can grant items, trigger flags, or start combat. Weighted selection ensures variety.

4. **Safe havens as story hubs:** Towns provide guaranteed safety, merchants, and progression points. Sanctuary rooms offer one-time safe rests in dungeons.

5. **Two-step rest process:** `initiateRest()` calculates recovery (pure), `completeRest()` applies it (mutation). Allows camp events to interrupt before recovery is applied.

---

## Success Criteria

Phase 3 is complete when:

- [ ] Player can short rest (50% recovery, instant)
- [ ] Player can long rest (100% recovery, camp events)
- [ ] Camp events trigger randomly with weighted selection
- [ ] Combat from camp events returns to rest completion
- [ ] Safe havens provide guaranteed full recovery
- [ ] Merchant accessible from safe havens (existing MerchantScreen integration)
- [ ] Sanctuary rooms can be used once
- [ ] All unit tests pass (15+ tests across logic/stores)
- [ ] Manual verification checklist complete
- [ ] Rest integrates with story flow (return to narrative)

**Estimated Completion:** ~3-5 days of development + testing

**Next Phase:** Phase 4 - Character Progression (levels 1-5, feats, skills)

---

## Plan Complete

Plan saved to `docs/plans/2025-12-31-phase-3.md`.

**Two execution options:**

**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

**Which approach would you like to use?**

---

# FAQ

## How will the rest system work from a player's POV? How will they know it's time to rest?

### How Players Know It's Time to Rest

Visual Indicators:
1. HP/Mana bars - Displayed during story and combat
2. After combat - Victory screen shows remaining HP/mana
3. Story context - Narrative hints: "You're exhausted from the fight..." or "Night is falling..."

### How Players Trigger Rest

Integrated into the narrative - Rest is offered as story choices, not a menu button:

#### Example 1: After Combat

[Story Node: Post-Wolf Battle]

You stand over the fallen wolf, breathing heavily.
The forest grows quiet again.

Choices:
‚Üí Rest here and tend your wounds
‚Üí Press on toward the tower
‚Üí Return to Oakhaven

Selecting "Rest here" ‚Üí Opens RestScreen

#### Example 2: During Exploration

[Story Node: Forest Clearing]

You find a small clearing. The setting sun
casts long shadows through the trees.

Choices:
‚Üí Make camp for the night
‚Üí Continue through the forest
‚Üí Investigate the strange light [Perception DC 12]

Selecting "Make camp" ‚Üí Opens RestScreen

#### Example 3: Safe Haven (Town)

[Story Node: Oakhaven - The Splintered Shield Inn]

The warm tavern offers respite from your journey.

Choices:
‚Üí Rest at the inn (guaranteed safety)
‚Üí Visit the merchant
‚Üí Speak with the magistrate
‚Üí Leave town

Selecting "Rest at the inn" ‚Üí Opens RestScreen (safe haven mode)

### The RestScreen Experience

Once the player chooses to rest, they see:

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           REST SCREEN              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Current HP: 15/30                  ‚ïë
‚ïë Current Mana: 6/12                 ‚ïë
‚ïë                                    ‚ïë
‚ïë [Short Rest]                       ‚ïë
‚ïë Restore 50% HP and Mana            ‚ïë
‚ïë (instant, safe)                    ‚ïë
‚ïë                                    ‚ïë
‚ïë [Long Rest]                        ‚ïë
‚ïë Restore 100% HP and Mana           ‚ïë
‚ïë (camp events possible) ‚ö†Ô∏è          ‚ïë
‚ïë                                    ‚ïë
‚ïë [Rest at Inn] (if in town)         ‚ïë
‚ïë Full recovery in safety            ‚ïë
‚ïë Access merchant                    ‚ïë
‚ïë                                    ‚ïë
‚ïë [Continue Adventure]               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

### Rest Outcomes

Short Rest (always safe):
Recovery Complete!
HP: 15 ‚Üí 30 (+15)
Mana: 6 ‚Üí 12 (+6)

[Return to Story]

Long Rest (risky in wilderness):
Camp Event: Distant Howls

As you settle in for the night, you hear
wolves howling in the distance...

‚Üí Investigate the sounds [leads to combat]
‚Üí Keep watch and ignore them [continue rest]

OR if no event:
Recovery Complete!
HP: 15 ‚Üí 30 (+15)
Mana: 6 ‚Üí 12 (+6)
All abilities restored!

[Return to Story]

Safe Haven Rest (guaranteed safety):
You rest peacefully at the inn.

Recovery Complete!
HP: 15 ‚Üí 30 (+15)
Mana: 6 ‚Üí 12 (+6)
All abilities restored!

[Visit Merchant] [Return to Story]

### Key Design Points

1. Context-Aware Choices

The narrative system gates rest options based on location:
- Anywhere: Short rest available
- Wilderness/dungeons: Long rest available (risky)
- Safe havens (towns): Inn rest (guaranteed safety + services)
- Sanctuary rooms: Long rest (one-time use)

2. Player Decision Points

Rest is a choice, not automatic:
- Low HP? Player decides: "Rest now or push forward?"
- Night falling? "Camp here (risky) or return to town (safe)?"
- Found sanctuary room? "Use it now or save for later?"

3. Story Integration

Rest isn't a separate "game menu" - it's woven into the narrative:
```
// In campaign data:
{
id: 'post-wolf-battle',
description: 'You stand victorious but wounded...',
choices: [
{
text: 'Rest and recover',
outcome: { type: 'goto', nodeId: 'trigger-rest-screen' }
},
{
text: 'Press onward',
outcome: { type: 'goto', nodeId: 'tower-approach' }
}
]
}
```

4. Risk/Reward Tension

- Short rest: Safe but only 50% recovery
- Long rest: Full recovery but camp events (possible combat)
- Return to town: Guaranteed safety but takes time (story-wise)

5. Visual Feedback

Player always sees:
- Current HP/mana before choosing
- Recovery amounts in real-time
- Event notifications
- Can't spam rest (narrative controls availability)

Example Full Flow

Player just beat a tough enemy:

1. Combat Victory ‚Üí HP: 8/30, Mana: 2/12 (very low!)
2. Story Node: "You're barely standing. The tower looms ahead."
3. Choices shown:
   - ‚ù§Ô∏è "Rest here" (player sees they're at 8 HP, knows they need this)
   - ‚öîÔ∏è "Continue to tower" (risky!)
   - üèòÔ∏è "Return to Oakhaven" (safe but backtracking)
4. Player chooses "Rest here" ‚Üí RestScreen opens
5. RestScreen shows:
   - Current: 8/30 HP, 2/12 Mana (red/critical)
   - Short Rest: +15 HP, +6 Mana (would be 23/30 - playable)
   - Long Rest: Full recovery (but risky - camp event 40% chance)
6. Player chooses Long Rest (needs full HP for tower)
7. Camp Event triggers: "Night Prowler"
8. Player defeats wolf (tough fight but manages)
9. Rest completes: HP/Mana ‚Üí 30/30 (full)
10. Return to story: "Morning breaks. The tower awaits."

TL;DR: Players trigger rest through narrative choices, see clear HP/mana displays, choose between safe/risky options, 
potentially face camp events, then return to story. It's integrated, not menu-driven.